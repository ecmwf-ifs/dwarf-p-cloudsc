! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

PROGRAM DWARF_CLOUDSC

USE PARKIND1, ONLY: JPIM, JPIB
USE CLOUDSC_MPI_MOD, ONLY: CLOUDSC_MPI_INIT, CLOUDSC_MPI_END, NUMPROC, IRANK
USE CLOUDSC_GLOBAL_STATE_MOD, ONLY: CLOUDSC_GLOBAL_STATE
USE CLOUDSC_DRIVER_MOD, ONLY: CLOUDSC_DRIVER
USE EC_PMON_MOD, ONLY: EC_PMON

USE YOEPHLI  , ONLY : YREPHLI
USE YOECLDP  , ONLY : YRECLDP, NCLV, NCLDQL, NCLDQI
USE YOEPHLI  , ONLY : YREPHLI

USE YOECLDP  , ONLY : TECLDP
USE YOEPHLI  , ONLY : TEPHLI
USE YOMCST   , ONLY : TOMCST
USE YOETHF   , ONLY : TOETHF

IMPLICIT NONE

CHARACTER(LEN=20) :: CLARG
INTEGER(KIND=JPIM) :: IARGS, LENARG, JARG, I

INTEGER(KIND=JPIM) :: NUMOMP   = 1     ! Number of OpenMP threads for this run
INTEGER(KIND=JPIM) :: NGPTOTG  = 16384 ! Number of grid points (as read from command line)
INTEGER(KIND=JPIM) :: NPROMA   = 32    ! NPROMA blocking factor (currently active)
INTEGER(KIND=JPIM) :: NGPTOT           ! Local number of grid points

TYPE(CLOUDSC_GLOBAL_STATE) :: GLOBAL_STATE

INTEGER(KIND=JPIB) :: ENERGY, POWER
CHARACTER(LEN=1)   :: CLEC_PMON


TYPE(TOMCST)    :: YDOMCST
TYPE(TOETHF)    :: YDOETHF
TYPE(TECLDP)    :: YDECLDP
TYPE(TEPHLI)    :: YDEPHLI


CALL GET_ENVIRONMENT_VARIABLE('EC_PMON', CLEC_PMON)
IF (CLEC_PMON == '1') THEN
  CALL EC_PMON(ENERGY, POWER)
  print *, "EC_PMON:: Initial (idle) power: ", POWER
END IF

IARGS = COMMAND_ARGUMENT_COUNT()

! Get the number of OpenMP threads to use for the benchmark
if (IARGS >= 1) then
   CALL GET_COMMAND_ARGUMENT(1, CLARG, LENARG)
   READ(CLARG(1:LENARG),*) NUMOMP
end if

! Initialize MPI environment
CALL CLOUDSC_MPI_INIT(NUMOMP)

! Get total number of grid points (NGPTOT) with which to run the benchmark
IF (IARGS >= 2) THEN
  CALL GET_COMMAND_ARGUMENT(2, CLARG, LENARG)
  READ(CLARG(1:LENARG),*) NGPTOTG
END IF

! Determine local number of grid points
NGPTOT = (NGPTOTG - 1) / NUMPROC + 1
if (IRANK == NUMPROC - 1) then
  NGPTOT = NGPTOTG - (NUMPROC - 1) * NGPTOT
end if

! Get the block size (NPROMA) for which to run the benchmark  
IF (IARGS >= 3) THEN
  CALL GET_COMMAND_ARGUMENT(3, CLARG, LENARG)
  READ(CLARG(1:LENARG),*) NPROMA
ENDIF

! TODO: Create a global global memory state from serialized input data
CALL GLOBAL_STATE%LOAD(NPROMA, NGPTOT, NGPTOTG)

CALL INITIALIZE_PARAMETER_DATATYPES(YDOMCST, YDOETHF, YDECLDP, YDEPHLI )

! Call the driver to perform the parallel loop over our kernel
CALL CLOUDSC_DRIVER(NUMOMP, NPROMA, GLOBAL_STATE%KLEV, NGPTOT, NGPTOTG, &
     & GLOBAL_STATE%KFLDX, GLOBAL_STATE%PTSPHY, &
     & GLOBAL_STATE%PT, GLOBAL_STATE%PQ, &
     & GLOBAL_STATE%TENDENCY_CML, GLOBAL_STATE%TENDENCY_TMP, GLOBAL_STATE%TENDENCY_LOC, &
     & GLOBAL_STATE%PVFA,    GLOBAL_STATE%PVFL,  GLOBAL_STATE%PVFI, &
     & GLOBAL_STATE%PDYNA,   GLOBAL_STATE%PDYNL, GLOBAL_STATE%PDYNI, &
     & GLOBAL_STATE%PHRSW,   GLOBAL_STATE%PHRLW, &
     & GLOBAL_STATE%PVERVEL, GLOBAL_STATE%PAP,   GLOBAL_STATE%PAPH, &
     & GLOBAL_STATE%PLSM,    GLOBAL_STATE%LDCUM, GLOBAL_STATE%KTYPE, &
     & GLOBAL_STATE%PLU,     GLOBAL_STATE%PLUDE, GLOBAL_STATE%PSNDE, &
     & GLOBAL_STATE%PMFU,    GLOBAL_STATE%PMFD, &
     & GLOBAL_STATE%PA,      GLOBAL_STATE%PCLV,  GLOBAL_STATE%PSUPSAT,&
     & GLOBAL_STATE%PLCRIT_AER, GLOBAL_STATE%PICRIT_AER, GLOBAL_STATE%PRE_ICE, &
     & GLOBAL_STATE%PCCN,     GLOBAL_STATE%PNICE,&
     & GLOBAL_STATE%PCOVPTOT, GLOBAL_STATE%PRAINFRAC_TOPRFZ, &
     & GLOBAL_STATE%PFSQLF,   GLOBAL_STATE%PFSQIF ,  GLOBAL_STATE%PFCQNNG,  GLOBAL_STATE%PFCQLNG, &
     & GLOBAL_STATE%PFSQRF,   GLOBAL_STATE%PFSQSF ,  GLOBAL_STATE%PFCQRNG,  GLOBAL_STATE%PFCQSNG, &
     & GLOBAL_STATE%PFSQLTUR, GLOBAL_STATE%PFSQITUR, &
     & GLOBAL_STATE%PFPLSL,   GLOBAL_STATE%PFPLSN,   GLOBAL_STATE%PFHPSL,   GLOBAL_STATE%PFHPSN, &
     & YDOMCST, YDOETHF, YDECLDP, YDEPHLI)

! Validate the output against serialized reference data
CALL GLOBAL_STATE%VALIDATE(NPROMA, NGPTOT, NGPTOTG)

! Tear down MPI environment
CALL CLOUDSC_MPI_END()

CONTAINS
SUBROUTINE INITIALIZE_PARAMETER_DATATYPES(YDOMCST, YDOETHF, YDECLDP, YDEPHLI )
USE YOMCST   , ONLY : RETV, RG  ,RCPD     ,&
 & RLVTT    ,RLSTT    ,RLMLT    ,RTT     ,RD, &
   RA, RPI, RV
USE YOETHF   , ONLY : R2ES     ,R3LES    ,R3IES    ,R4LES    ,&
 & R4IES    ,R5LES    ,R5IES    ,R5ALVCP  ,R5ALSCP  ,&
 & RALVDCP  ,RALSDCP  ,RTWAT    ,RTICE    ,RTICECU   ,&
 & RTWAT_RTICE_R      ,RTWAT_RTICECU_R    ,RVTMP2, &
 & RALFDCP, RKOOP1, RKOOP2
USE YOECLDP  , ONLY : YRECLDP
USE YOEPHLI  , ONLY : YREPHLI
USE YOETHF   , ONLY : RVTMP2
USE FCTTRE_MOD, ONLY : FCTTRE_CONSTANTS_SET
TYPE(TOMCST)      ,INTENT(INOUT) :: YDOMCST
TYPE(TOETHF)      ,INTENT(INOUT) :: YDOETHF
TYPE(TECLDP)      ,INTENT(INOUT) :: YDECLDP
TYPE(TEPHLI)      ,INTENT(INOUT) :: YDEPHLI
YDECLDP%RCLCRIT         = YRECLDP%RCLCRIT
YDECLDP%RKCONV          = YRECLDP%RKCONV
YDECLDP%RLMIN           = YRECLDP%RLMIN
YDECLDP%RPECONS         = YRECLDP%RPECONS
YDEPHLI%LPHYLIN         = YREPHLI%LPHYLIN
YDEPHLI%RLPTRC          = YREPHLI%RLPTRC
YDOETHF%RVTMP2          =  RVTMP2
YDEPHLI%LPHYLIN         = .true.
YDOMCST%RG              = RG
YDOMCST%RD              = RD
YDOMCST%RCPD            = RCPD
YDOMCST%RETV            = RETV
YDOMCST%RLVTT           = RLVTT
YDOMCST%RLSTT           = RLSTT
YDOMCST%RLMLT           = RLMLT
YDOMCST%RTT             = RTT
YDOMCST%RV              = RV
YDOMCST%RA              = RA
YDOMCST%RPI             = RPI
YDOETHF%R2ES            = R2ES
YDOETHF%R3LES           = R3LES
YDOETHF%R3IES           = R3IES
YDOETHF%R4LES           = R4LES
YDOETHF%R4IES           = R4IES
YDOETHF%R5LES           = R5LES
YDOETHF%R5IES           = R5IES
YDOETHF%R5ALVCP         = R5ALVCP
YDOETHF%R5ALSCP         = R5ALSCP
YDOETHF%RALVDCP         = RALVDCP
YDOETHF%RALSDCP         = RALSDCP
YDOETHF%RALFDCP         = RALFDCP
YDOETHF%RTWAT           = RTWAT
YDOETHF%RTICE           = RTICE
YDOETHF%RTICECU         = RTICECU
YDOETHF%RTWAT_RTICE_R   = RTWAT_RTICE_R
YDOETHF%RTWAT_RTICECU_R = RTWAT_RTICECU_R
YDOETHF%RKOOP1          = RKOOP1
YDOETHF%RKOOP2          = RKOOP2

CALL FCTTRE_CONSTANTS_SET(  &
 &                 RG_IN=RG, RD_IN=RD, RCPD_IN=RCPD, RETV_IN=RETV, RLVTT_IN=RLVTT, &
 &                 RLSTT_IN=RLSTT, RLMLT_IN=RLMLT, RTT_IN=RTT, RV_IN=RV, RA_IN=RA, RPI_IN=RPI, &
 &                 R2ES_IN=R2ES, R3LES_IN=R3LES, R3IES_IN=R3IES, &
 &                R4LES_IN=R4LES, R4IES_IN=R4IES, R5LES_IN=R5LES, R5IES_IN=R5IES, &
 &                 R5ALVCP_IN=R5ALVCP, R5ALSCP_IN=R5ALSCP, RALVDCP_IN=RALVDCP, RALSDCP_IN=RALSDCP, &
 &                 RALFDCP_IN=RALFDCP, RTWAT_IN=RTWAT, RTICE_IN=RTICE, RTICECU_IN=RTICECU, &
 &                 RTWAT_RTICE_R_IN=RTWAT_RTICE_R, RTWAT_RTICECU_R_IN=RTWAT_RTICECU_R, &
 &                 RKOOP1_IN=RKOOP1, RKOOP2_IN=RKOOP2)

END SUBROUTINE INITIALIZE_PARAMETER_DATATYPES

END PROGRAM DWARF_CLOUDSC
