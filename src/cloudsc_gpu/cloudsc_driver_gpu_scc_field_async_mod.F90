! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC_MOD

  USE PARKIND1, ONLY: JPIM, JPRB
  USE YOMPHYDER, ONLY: STATE_TYPE
  USE YOECLDP, ONLY : NCLV, YRECLDP, TECLDP
  USE CLOUDSC_MPI_MOD, ONLY: NUMPROC, IRANK
  USE TIMER_MOD, ONLY : PERFORMANCE_TIMER, GET_THREAD_NUM

  USE CLOUDSC_GPU_SCC_MOD, ONLY: CLOUDSC_SCC
  USE CLOUDSC_AUX_TYPE_MOD, ONLY: CLOUDSC_AUX_TYPE
  USE CLOUDSC_FLUX_TYPE_MOD, ONLY: CLOUDSC_FLUX_TYPE
  USE CLOUDSC_STATE_TYPE_MOD, ONLY: CLOUDSC_STATE_TYPE
  USE FIELD_MODULE, ONLY : FIELD_4RB_VIEW, FIELD_5RB_VIEW, FIELD_3RB_VIEW, FIELD_3IM_VIEW, FIELD_3LM_VIEW
  USE FIELD_DEFAULTS_MODULE
  USE FIELD_ASYNC_MODULE

  IMPLICIT NONE

CONTAINS

  SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC( &
     & NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG, KFLDX, PTSPHY, &
     & AUX, FLUX, TENDENCY_TMP, TENDENCY_LOC, USE_PACKED, NQUEUES)
     
    ! Driver routine that invokes the optimized CLAW-based CLOUDSC GPU kernel

    INTEGER(KIND=JPIM)                                    :: NUMOMP, NPROMA, NLEV, NGPTOT, NGPBLKS, NGPTOTG
    INTEGER(KIND=JPIM)                                    :: KFLDX 
    REAL(KIND=JPRB)                                       :: PTSPHY       ! Physics timestep
    TYPE(CLOUDSC_AUX_TYPE),   INTENT(INOUT)               :: AUX
    TYPE(CLOUDSC_FLUX_TYPE),  INTENT(INOUT)               :: FLUX
    TYPE(CLOUDSC_STATE_TYPE), INTENT(INOUT)               :: TENDENCY_LOC, TENDENCY_TMP
    LOGICAL, INTENT(IN)                                   :: USE_PACKED
    INTEGER(KIND=JPIM), INTENT(IN)                        :: NQUEUES

    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PT(:)       ! T at start of callpar
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PQ(:)       ! Q at start of callpar
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PVFA(:)     ! CC from VDF scheme
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PVFL(:)     ! Liq from VDF scheme
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PVFI(:)     ! Ice from VDF scheme
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PDYNA(:)    ! CC from Dynamics
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PDYNL(:)    ! Liq from Dynamics
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PDYNI(:)    ! Liq from Dynamics
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PHRSW(:)    ! Short-wave heating rate
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PHRLW(:)    ! Long-wave heating rate
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PVERVEL(:)  ! Vertical velocity
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PAP(:)      ! Pressure on full levels
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PAPH(:)     ! Pressure on half levels
    TYPE(FIELD_3RB_VIEW), ALLOCATABLE  :: PLSM(:)       ! Land fraction (0-1)
    TYPE(FIELD_3LM_VIEW), ALLOCATABLE  :: LDCUM(:)      ! Convection active
    TYPE(FIELD_3IM_VIEW), ALLOCATABLE  :: KTYPE(:)      ! Convection type 0,1,2
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PLU(:)      ! Conv. condensate
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PLUDE(:)    ! Conv. detrained water
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PSNDE(:)    ! Conv. detrained snow
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PMFU(:)     ! Conv. mass flux up
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PMFD(:)     ! Conv. mass flux down
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PA(:)       ! Original Cloud fraction (t)
    TYPE(FIELD_5RB_VIEW), ALLOCATABLE  :: PCLV(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PSUPSAT(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PLCRIT_AER(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PICRIT_AER(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PRE_ICE(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PCCN(:)     ! liquid cloud condensation nuclei
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PNICE(:)    ! ice number concentration (cf. CCN)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PCOVPTOT(:)    ! Precip fraction
    TYPE(FIELD_3RB_VIEW), ALLOCATABLE  :: PRAINFRAC_TOPRFZ(:)
    ! Flux diagnostics for DDH budget
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQLF(:)    ! Flux of liquid
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQIF(:)    ! Flux of ice
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFCQLNG(:)   ! -ve corr for liq
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFCQNNG(:)   ! -ve corr for ice
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQRF(:)    ! Flux diagnostics
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQSF(:)    !    for DDH, generic
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFCQRNG(:)   ! rain
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFCQSNG(:)   ! snow
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQLTUR(:)  ! liquid flux due to VDF
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFSQITUR(:)  ! ice flux due to VDF
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFPLSL(:)    ! liq+rain sedim flux
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFPLSN(:)    ! ice+snow sedim flux
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFHPSL(:)    ! Enthalpy flux for liq
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: PFHPSN(:)    ! ice number concentration (cf. CCN)

    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_LOC_T(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_LOC_Q(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_LOC_A(:)
    TYPE(FIELD_5RB_VIEW), ALLOCATABLE  :: TEND_LOC_CLD(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_TMP_T(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_TMP_Q(:)
    TYPE(FIELD_4RB_VIEW), ALLOCATABLE  :: TEND_TMP_A(:)
    TYPE(FIELD_5RB_VIEW), ALLOCATABLE  :: TEND_TMP_CLD(:)

    INTEGER(KIND=JPIM) :: JKGLO,IBL,ICEND
    TYPE(PERFORMANCE_TIMER) :: TIMER
    INTEGER(KIND=JPIM) :: TID ! thread id from 0 .. NUMOMP - 1

    ! Local copy of cloud parameters for offload
    TYPE(TECLDP) :: LOCAL_YRECLDP

     ! double blocking variables
    INTEGER(KIND=JPIM) :: QUEUE
    INTEGER(KIND=JPIM) :: OFFSET
    INTEGER(KIND=JPIM) :: BLOCK_BUFFER_SIZE     ! block size for blocks in outer loop
    INTEGER(KIND=JPIM) :: BLOCK_COUNT           ! number of blocks
    INTEGER(KIND=JPIM) :: BLOCK_IDX             ! idx of current block in [1,BLOCK_COUNT]
    INTEGER(KIND=JPIM) :: BLOCK_START           ! start of current block in [1,NGPBLKS]
    INTEGER(KIND=JPIM) :: BLOCK_END             ! end of current block in [1,NGPBLKS]
    INTEGER(KIND=JPIM) :: BLOCK_SIZE            ! end of current block in [1,NGPBLKS]
    INTEGER(KIND=JPIM) :: IBLLOC                ! local loop idx inside inner block loop
    INTEGER(KIND=JPIM) :: BLK_BOUNDS(2)         ! Array holding BLOCK_START and BLOCK_SIZE

    NGPBLKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
1003 format(5x,'NUMPROC=',i0,', NUMOMP=',i0,', NGPTOTG=',i0,', NPROMA=',i0,', NGPBLKS=',i0)
    if (irank == 0) then
      write(0,1003) NUMPROC,NUMOMP,NGPTOTG,NPROMA,NGPBLKS
    end if

    ! Global timer for the parallel region
    CALL TIMER%START(NUMOMP)
    
    ! Workaround for PGI / OpenACC oddities:
    ! Create a local copy of the parameter struct to ensure they get
    ! moved to the device the in ``acc data`` clause below
    LOCAL_YRECLDP = YRECLDP
    !$acc enter data copyin(LOCAL_YRECLDP)

    BLOCK_BUFFER_SIZE = MIN(512,NGPBLKS)
    BLOCK_COUNT=(NGPBLKS+BLOCK_BUFFER_SIZE-1)/BLOCK_BUFFER_SIZE
    
    WRITE(0,*), 'BLOCK_BUFFER_SIZE=', BLOCK_BUFFER_SIZE
    WRITE(0,*), 'BLOCK_COUNT=', BLOCK_COUNT
    WRITE(0,*), 'NQUEUES=', NQUEUES

    ! Allocate view pointer structs
    ALLOCATE(PT(NQUEUES))
    ALLOCATE(PQ(NQUEUES))
    ALLOCATE(PVFA(NQUEUES))
    ALLOCATE(PVFL(NQUEUES))
    ALLOCATE(PVFI(NQUEUES))
    ALLOCATE(PDYNA(NQUEUES))
    ALLOCATE(PDYNL(NQUEUES))
    ALLOCATE(PDYNI(NQUEUES))
    ALLOCATE(PHRSW(NQUEUES))
    ALLOCATE(PHRLW(NQUEUES))
    ALLOCATE(PVERVEL(NQUEUES))
    ALLOCATE(PAP(NQUEUES))
    ALLOCATE(PAPH(NQUEUES))
    ALLOCATE(PLSM(NQUEUES))
    ALLOCATE(LDCUM(NQUEUES))
    ALLOCATE(KTYPE(NQUEUES))
    ALLOCATE(PLU(NQUEUES))
    ALLOCATE(PLUDE(NQUEUES))
    ALLOCATE(PSNDE(NQUEUES))
    ALLOCATE(PMFU(NQUEUES))
    ALLOCATE(PMFD(NQUEUES))
    ALLOCATE(PA(NQUEUES))
    ALLOCATE(PCLV(NQUEUES))
    ALLOCATE(PSUPSAT(NQUEUES))
    ALLOCATE(PLCRIT_AER(NQUEUES))
    ALLOCATE(PICRIT_AER(NQUEUES))
    ALLOCATE(PRE_ICE(NQUEUES))
    ALLOCATE(PCCN(NQUEUES))
    ALLOCATE(PNICE(NQUEUES))
    ALLOCATE(PCOVPTOT(NQUEUES))
    ALLOCATE(PRAINFRAC_TOPRFZ(NQUEUES))
    ALLOCATE(PFSQLF(NQUEUES))
    ALLOCATE(PFSQIF(NQUEUES))
    ALLOCATE(PFCQLNG(NQUEUES))
    ALLOCATE(PFCQNNG(NQUEUES))
    ALLOCATE(PFSQRF(NQUEUES))
    ALLOCATE(PFSQSF(NQUEUES))
    ALLOCATE(PFCQRNG(NQUEUES))
    ALLOCATE(PFCQSNG(NQUEUES))
    ALLOCATE(PFSQLTUR(NQUEUES))
    ALLOCATE(PFSQITUR(NQUEUES))
    ALLOCATE(PFPLSL(NQUEUES))
    ALLOCATE(PFPLSN(NQUEUES))
    ALLOCATE(PFHPSL(NQUEUES))
    ALLOCATE(PFHPSN(NQUEUES))
    ALLOCATE(TEND_LOC_T(NQUEUES))
    ALLOCATE(TEND_LOC_Q(NQUEUES))
    ALLOCATE(TEND_LOC_A(NQUEUES))
    ALLOCATE(TEND_LOC_CLD(NQUEUES))
    ALLOCATE(TEND_TMP_T(NQUEUES))
    ALLOCATE(TEND_TMP_Q(NQUEUES))
    ALLOCATE(TEND_TMP_A(NQUEUES))
    ALLOCATE(TEND_TMP_CLD(NQUEUES))

    !$acc enter data copyin(PT)
    !$acc enter data copyin(PQ)
    !$acc enter data copyin(PVFA)
    !$acc enter data copyin(PVFL)
    !$acc enter data copyin(PVFI)
    !$acc enter data copyin(PDYNA)
    !$acc enter data copyin(PDYNL)
    !$acc enter data copyin(PDYNI)
    !$acc enter data copyin(PHRSW)
    !$acc enter data copyin(PHRLW)
    !$acc enter data copyin(PVERVEL)
    !$acc enter data copyin(PAP)
    !$acc enter data copyin(PAPH)
    !$acc enter data copyin(PLSM)
    !$acc enter data copyin(LDCUM)
    !$acc enter data copyin(KTYPE)
    !$acc enter data copyin(PLU)
    !$acc enter data copyin(PLUDE)
    !$acc enter data copyin(PSNDE)
    !$acc enter data copyin(PMFU)
    !$acc enter data copyin(PMFD)
    !$acc enter data copyin(PA)
    !$acc enter data copyin(PCLV)
    !$acc enter data copyin(PSUPSAT)
    !$acc enter data copyin(PLCRIT_AER)
    !$acc enter data copyin(PICRIT_AER)
    !$acc enter data copyin(PRE_ICE)
    !$acc enter data copyin(PCCN)
    !$acc enter data copyin(PNICE)
    !$acc enter data copyin(PCOVPTOT)
    !$acc enter data copyin(PRAINFRAC_TOPRFZ)
    !$acc enter data copyin(PFSQLF)
    !$acc enter data copyin(PFSQIF)
    !$acc enter data copyin(PFCQLNG)
    !$acc enter data copyin(PFCQNNG)
    !$acc enter data copyin(PFSQRF)
    !$acc enter data copyin(PFSQSF)
    !$acc enter data copyin(PFCQRNG)
    !$acc enter data copyin(PFCQSNG)
    !$acc enter data copyin(PFSQLTUR)
    !$acc enter data copyin(PFSQITUR)
    !$acc enter data copyin(PFPLSL)
    !$acc enter data copyin(PFPLSN)
    !$acc enter data copyin(PFHPSL)
    !$acc enter data copyin(PFHPSN)
    !$acc enter data copyin(TEND_LOC_T)
    !$acc enter data copyin(TEND_LOC_Q)
    !$acc enter data copyin(TEND_LOC_A)
    !$acc enter data copyin(TEND_LOC_CLD)
    !$acc enter data copyin(TEND_TMP_T)
    !$acc enter data copyin(TEND_TMP_Q)
    !$acc enter data copyin(TEND_TMP_A)
    !$acc enter data copyin(TEND_TMP_CLD)

    ! Allocate NQUEUES*BLK_SIZE on device for each field
      CALL AUX%F_PT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PQ%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PVFA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PVFL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PVFI%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PDYNA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PDYNL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PDYNI%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PHRSW%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PHRLW%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PVERVEL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PAP%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PLU%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PSNDE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PMFU%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PMFD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PA%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PSUPSAT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PLCRIT_AER%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PICRIT_AER%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PRE_ICE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PCCN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PNICE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      
      CALL AUX%F_PAPH%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PLSM%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_LDCUM%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_KTYPE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PCLV%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      
      CALL TENDENCY_TMP%F_T%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_TMP%F_Q%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_TMP%F_A%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_TMP%F_CLD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])

      CALL AUX%F_PLUDE%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PCOVPTOT%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL AUX%F_PRAINFRAC_TOPRFZ%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      
      CALL FLUX%F_PFSQLF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFSQIF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFCQLNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFCQNNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFSQRF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFSQSF%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFCQRNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFCQSNG%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFSQLTUR%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFSQITUR%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFPLSL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFPLSN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFHPSL%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL FLUX%F_PFHPSN%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      
      CALL TENDENCY_LOC%F_T%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_LOC%F_Q%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_LOC%F_A%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])
      CALL TENDENCY_LOC%F_CLD%CREATE_DEVICE_DATA(BLK_BOUNDS=[1,NQUEUES*BLOCK_BUFFER_SIZE])

    DO BLOCK_IDX=0, BLOCK_COUNT-1
      BLOCK_START=BLOCK_IDX*BLOCK_BUFFER_SIZE+1
      BLOCK_END=MIN((BLOCK_IDX+1)*BLOCK_BUFFER_SIZE, NGPBLKS)
      BLK_BOUNDS=[BLOCK_START, BLOCK_END]
      QUEUE = MODULO(BLOCK_IDX,NQUEUES)+1
      OFFSET = (QUEUE-1)*BLOCK_BUFFER_SIZE
      BLOCK_SIZE = BLK_BOUNDS(2) - BLK_BOUNDS(1) + 1

      !$acc wait(QUEUE) async(QUEUE)

      WRITE(0,*) QUEUE, OFFSET, BLOCK_SIZE, BLOCK_START
      ! IF(USE_PACKED)THEN
      !   CALL AUX%DATA_RDONLY%SYNC_DEVICE_FORCE(BLK_BOUNDS=BLK_BOUNDS)
      !   CALL FLUX%DATA_WRONLY%SYNC_DEVICE_FORCE(BLK_BOUNDS=BLK_BOUNDS)
      !   CALL TENDENCY_TMP%FIELD_GANG%SYNC_DEVICE_FORCE(BLK_BOUNDS=BLK_BOUNDS)
      !   CALL TENDENCY_LOC%FIELD_GANG%SYNC_DEVICE_FORCE(BLK_BOUNDS=BLK_BOUNDS)
      !    ! If this is called then the subsequent FIELDS_RDONLY/RWONLY%PTR%GET_DEVICE_DATA()
      !    ! calls don't trigger any data movement, they just return an updated device pointer
      ! ENDIF
      ! TODO: CHANGE ACCESSOR METHOD WHEN USE_PACKED IS USED TO PREVENT DOUBLE TRANSFERS OF DATA      
      CALL AUX%F_PT%GET_DEVICE_DATA_FORCE(PT(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PQ%GET_DEVICE_DATA_FORCE(PQ(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFA%GET_DEVICE_DATA_FORCE(PVFA(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFL%GET_DEVICE_DATA_FORCE(PVFL(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVFI%GET_DEVICE_DATA_FORCE(PVFI(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNA%GET_DEVICE_DATA_FORCE(PDYNA(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNL%GET_DEVICE_DATA_FORCE(PDYNL(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PDYNI%GET_DEVICE_DATA_FORCE(PDYNI(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PHRSW%GET_DEVICE_DATA_FORCE(PHRSW(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PHRLW%GET_DEVICE_DATA_FORCE(PHRLW(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PVERVEL%GET_DEVICE_DATA_FORCE(PVERVEL(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PAP%GET_DEVICE_DATA_FORCE(PAP(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLU%GET_DEVICE_DATA_FORCE(PLU(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PSNDE%GET_DEVICE_DATA_FORCE(PSNDE(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PMFU%GET_DEVICE_DATA_FORCE(PMFU(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PMFD%GET_DEVICE_DATA_FORCE(PMFD(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PA%GET_DEVICE_DATA_FORCE(PA(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PSUPSAT%GET_DEVICE_DATA_FORCE(PSUPSAT(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLCRIT_AER%GET_DEVICE_DATA_FORCE(PLCRIT_AER(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PICRIT_AER%GET_DEVICE_DATA_FORCE(PICRIT_AER(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRE_ICE%GET_DEVICE_DATA_FORCE(PRE_ICE(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCCN%GET_DEVICE_DATA_FORCE(PCCN(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PNICE%GET_DEVICE_DATA_FORCE(PNICE(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      
      CALL AUX%F_PAPH%GET_DEVICE_DATA_FORCE(PAPH(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PLSM%GET_DEVICE_DATA_FORCE(PLSM(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_LDCUM%GET_DEVICE_DATA_FORCE(LDCUM(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_KTYPE%GET_DEVICE_DATA_FORCE(KTYPE(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCLV%GET_DEVICE_DATA_FORCE(PCLV(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      
      CALL TENDENCY_TMP%F_T%GET_DEVICE_DATA_FORCE(TEND_TMP_T(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_Q%GET_DEVICE_DATA_FORCE(TEND_TMP_Q(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_A%GET_DEVICE_DATA_FORCE(TEND_TMP_A(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_TMP%F_CLD%GET_DEVICE_DATA_FORCE(TEND_TMP_CLD(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      CALL AUX%F_PLUDE%GET_DEVICE_DATA_FORCE(PLUDE(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCOVPTOT%GET_DEVICE_DATA_FORCE(PCOVPTOT(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRAINFRAC_TOPRFZ%GET_DEVICE_DATA_FORCE(PRAINFRAC_TOPRFZ(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      
      CALL FLUX%F_PFSQLF%GET_DEVICE_DATA_FORCE(PFSQLF(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQIF%GET_DEVICE_DATA_FORCE(PFSQIF(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQLNG%GET_DEVICE_DATA_FORCE(PFCQLNG(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQNNG%GET_DEVICE_DATA_FORCE(PFCQNNG(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQRF%GET_DEVICE_DATA_FORCE(PFSQRF(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQSF%GET_DEVICE_DATA_FORCE(PFSQSF(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQRNG%GET_DEVICE_DATA_FORCE(PFCQRNG(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQSNG%GET_DEVICE_DATA_FORCE(PFCQSNG(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLTUR%GET_DEVICE_DATA_FORCE(PFSQLTUR(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQITUR%GET_DEVICE_DATA_FORCE(PFSQITUR(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSL%GET_DEVICE_DATA_FORCE(PFPLSL(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSN%GET_DEVICE_DATA_FORCE(PFPLSN(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSL%GET_DEVICE_DATA_FORCE(PFHPSL(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSN%GET_DEVICE_DATA_FORCE(PFHPSN(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      
      CALL TENDENCY_LOC%F_T%GET_DEVICE_DATA_FORCE(TEND_LOC_T(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_Q%GET_DEVICE_DATA_FORCE(TEND_LOC_Q(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_A%GET_DEVICE_DATA_FORCE(TEND_LOC_A(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_CLD%GET_DEVICE_DATA_FORCE(TEND_LOC_CLD(QUEUE)%P, BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      !$acc enter data attach(PT(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PQ(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PVFA(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PVFL(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PVFI(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PDYNA(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PDYNL(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PDYNI(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PHRSW(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PHRLW(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PVERVEL(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PAP(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PAPH(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PLSM(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(LDCUM(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(KTYPE(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PLU(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PLUDE(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PSNDE(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PMFU(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PMFD(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PA(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PCLV(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PSUPSAT(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PLCRIT_AER(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PICRIT_AER(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PRE_ICE(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PCCN(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PNICE(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PCOVPTOT(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PRAINFRAC_TOPRFZ(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQLF(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQIF(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFCQLNG(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFCQNNG(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQRF(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQSF(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFCQRNG(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFCQSNG(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQLTUR(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFSQITUR(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFPLSL(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFPLSN(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFHPSL(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(PFHPSN(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_LOC_T(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_LOC_Q(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_LOC_A(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_LOC_CLD(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_TMP_T(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_TMP_Q(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_TMP_A(QUEUE)%P) async(QUEUE)
      !$acc enter data attach(TEND_TMP_CLD(QUEUE)%P) async(QUEUE)

      ! Local timer for each thread
      TID = GET_THREAD_NUM()
      CALL TIMER%THREAD_START(TID)
      

!$acc data &
!$acc & present(LOCAL_YRECLDP, &
!$acc & PT, PQ,TEND_TMP_T,TEND_TMP_Q,&
!$acc & TEND_TMP_A, TEND_TMP_CLD, TEND_LOC_T, TEND_LOC_Q, &
!$acc & TEND_LOC_A, TEND_LOC_CLD, PVFA, PVFL, PVFI, &
!$acc & PDYNA, PDYNL, PDYNI, PHRSW,    PHRLW,&
!$acc & PVERVEL,  PAP,      PAPH,&
!$acc & PLSM,       LDCUM,      KTYPE, &
!$acc & PLU,      PLUDE,    PSNDE,    PMFU,     PMFD,&
!$acc & PA,       PCLV,   PSUPSAT,&
!$acc & PLCRIT_AER,PICRIT_AER,&
!$acc & PRE_ICE, PCCN,     PNICE,&
!$acc & PCOVPTOT, PRAINFRAC_TOPRFZ,&
!$acc & PFSQLF,   PFSQIF ,  PFCQNNG,  PFCQLNG,&
!$acc & PFSQRF,   PFSQSF ,  PFCQRNG,  PFCQSNG,&
!$acc & PFSQLTUR, PFSQITUR , &
!$acc & PFPLSL,   PFPLSN,   PFHPSL,   PFHPSN) async(QUEUE)
!$acc parallel loop gang vector_length(NPROMA) &
!$acc & async(QUEUE)
      DO IBLLOC=1, BLOCK_SIZE
        IBL= BLOCK_BUFFER_SIZE*BLOCK_IDX+IBLLOC
        JKGLO=(IBL-1)*NPROMA+1
        ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)
      ! DO JKGLO=1,NGPTOT,NPROMA ! just a way to loop over NGPBLKS
      !    IBL=(JKGLO-1)/NPROMA+1
      !    ICEND=MIN(NPROMA,NGPTOT-JKGLO+1)

         CALL CLOUDSC_SCC &
          & (1, ICEND, NPROMA, NLEV, PTSPHY,&
          & PT(QUEUE)%P(:,:,IBL), PQ(QUEUE)%P(:,:,IBL), &
          & TEND_TMP_T(QUEUE)%P(:,:,IBL), TEND_TMP_Q(QUEUE)%P(:,:,IBL), TEND_TMP_A(QUEUE)%P(:,:,IBL), TEND_TMP_CLD(QUEUE)%P(:,:,:,IBL), &
          & TEND_LOC_T(QUEUE)%P(:,:,IBL), TEND_LOC_Q(QUEUE)%P(:,:,IBL), TEND_LOC_A(QUEUE)%P(:,:,IBL), TEND_LOC_CLD(QUEUE)%P(:,:,:,IBL), &
          & PVFA(QUEUE)%P(:,:,IBL), PVFL(QUEUE)%P(:,:,IBL), PVFI(QUEUE)%P(:,:,IBL), PDYNA(QUEUE)%P(:,:,IBL), PDYNL(QUEUE)%P(:,:,IBL), PDYNI(QUEUE)%P(:,:,IBL), &
          & PHRSW(QUEUE)%P(:,:,IBL),    PHRLW(QUEUE)%P(:,:,IBL),&
          & PVERVEL(QUEUE)%P(:,:,IBL),  PAP(QUEUE)%P(:,:,IBL),      PAPH(QUEUE)%P(:,:,IBL),&
          & PLSM(QUEUE)%P(:,IBL),       LDCUM(QUEUE)%P(:,IBL),      KTYPE(QUEUE)%P(:,IBL), &
          & PLU(QUEUE)%P(:,:,IBL),      PLUDE(QUEUE)%P(:,:,IBL),    PSNDE(QUEUE)%P(:,:,IBL),    PMFU(QUEUE)%P(:,:,IBL),     PMFD(QUEUE)%P(:,:,IBL),&
          !---prognostic fields
          & PA(QUEUE)%P(:,:,IBL),       PCLV(QUEUE)%P(:,:,:,IBL),   PSUPSAT(QUEUE)%P(:,:,IBL),&
          !-- arrays for aerosol-cloud interactions
          & PLCRIT_AER(QUEUE)%P(:,:,IBL),PICRIT_AER(QUEUE)%P(:,:,IBL),&
          & PRE_ICE(QUEUE)%P(:,:,IBL),&
          & PCCN(QUEUE)%P(:,:,IBL),     PNICE(QUEUE)%P(:,:,IBL),&
          !---diagnostic output
          & PCOVPTOT(QUEUE)%P(:,:,IBL), PRAINFRAC_TOPRFZ(QUEUE)%P(:,IBL),&
          !---resulting fluxes
          & PFSQLF(QUEUE)%P(:,:,IBL),   PFSQIF (QUEUE)%P(:,:,IBL),  PFCQNNG(QUEUE)%P(:,:,IBL),  PFCQLNG(QUEUE)%P(:,:,IBL),&
          & PFSQRF(QUEUE)%P(:,:,IBL),   PFSQSF (QUEUE)%P(:,:,IBL),  PFCQRNG(QUEUE)%P(:,:,IBL),  PFCQSNG(QUEUE)%P(:,:,IBL),&
          & PFSQLTUR(QUEUE)%P(:,:,IBL), PFSQITUR (QUEUE)%P(:,:,IBL), &
          & PFPLSL(QUEUE)%P(:,:,IBL),   PFPLSN(QUEUE)%P(:,:,IBL),   PFHPSL(QUEUE)%P(:,:,IBL),   PFHPSN(QUEUE)%P(:,:,IBL),&
          & YRECLDP=LOCAL_YRECLDP)

      ENDDO
!$acc end parallel loop
!$acc end data

      CALL TIMER%THREAD_END(TID)

      CALL AUX%F_PLUDE%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PCOVPTOT%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL AUX%F_PRAINFRAC_TOPRFZ%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQIF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQLNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQNNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQRF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQSF%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQRNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFCQSNG%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQLTUR%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFSQITUR%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSL%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFPLSN%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSL%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL FLUX%F_PFHPSN%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_T%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_Q%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_A%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)
      CALL TENDENCY_LOC%F_CLD%SYNC_HOST_FORCE(BLK_BOUNDS=BLK_BOUNDS, QUEUE=QUEUE, OFFSET=OFFSET)

      !$acc exit data detach(PT(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PQ(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PVFA(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PVFL(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PVFI(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PDYNA(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PDYNL(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PDYNI(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PHRSW(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PHRLW(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PVERVEL(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PAP(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PAPH(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PLSM(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(LDCUM(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(KTYPE(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PLU(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PLUDE(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PSNDE(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PMFU(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PMFD(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PA(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PCLV(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PSUPSAT(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PLCRIT_AER(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PICRIT_AER(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PRE_ICE(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PCCN(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PNICE(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PCOVPTOT(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PRAINFRAC_TOPRFZ(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQLF(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQIF(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFCQLNG(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFCQNNG(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQRF(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQSF(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFCQRNG(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFCQSNG(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQLTUR(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFSQITUR(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFPLSL(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFPLSN(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFHPSL(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(PFHPSN(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_LOC_T(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_LOC_Q(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_LOC_A(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_LOC_CLD(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_TMP_T(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_TMP_Q(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_TMP_A(QUEUE)%P) async(QUEUE)
      !$acc exit data detach(TEND_TMP_CLD(QUEUE)%P) async(QUEUE)

    END DO ! End of block loop
    
    WRITE(0,*) "GOT HERE"
!$acc wait ! Wait for all async queues to finish

!$acc exit data delete(local_yrecldp)

    CALL TIMER%END()

    ! On GPUs, adding block-level column totals is cumbersome and
    ! error prone, and of little value due to the large number of
    ! processing "thread teams". Instead we register the total here.
    CALL TIMER%THREAD_LOG(TID=TID, IGPC=NGPTOT)

    CALL TIMER%PRINT_PERFORMANCE(NPROMA, NGPBLKS, NGPTOT)

    DO QUEUE=1,NQUEUES
       NULLIFY(PT(QUEUE)%P)
       NULLIFY(PQ(QUEUE)%P)
       NULLIFY(PVFA(QUEUE)%P)
       NULLIFY(PVFL(QUEUE)%P)
       NULLIFY(PVFI(QUEUE)%P)
       NULLIFY(PDYNA(QUEUE)%P)
       NULLIFY(PDYNL(QUEUE)%P)
       NULLIFY(PDYNI(QUEUE)%P)
       NULLIFY(PHRSW(QUEUE)%P)
       NULLIFY(PHRLW(QUEUE)%P)
       NULLIFY(PVERVEL(QUEUE)%P)
       NULLIFY(PAP(QUEUE)%P)
       NULLIFY(PAPH(QUEUE)%P)
       NULLIFY(PLSM(QUEUE)%P)
       NULLIFY(LDCUM(QUEUE)%P)
       NULLIFY(KTYPE(QUEUE)%P)
       NULLIFY(PLU(QUEUE)%P)
       NULLIFY(PLUDE(QUEUE)%P)
       NULLIFY(PSNDE(QUEUE)%P)
       NULLIFY(PMFU(QUEUE)%P)
       NULLIFY(PMFD(QUEUE)%P)
       NULLIFY(PA(QUEUE)%P)
       NULLIFY(PCLV(QUEUE)%P)
       NULLIFY(PSUPSAT(QUEUE)%P)
       NULLIFY(PLCRIT_AER(QUEUE)%P)
       NULLIFY(PICRIT_AER(QUEUE)%P)
       NULLIFY(PRE_ICE(QUEUE)%P)
       NULLIFY(PCCN(QUEUE)%P)
       NULLIFY(PNICE(QUEUE)%P)
       NULLIFY(PCOVPTOT(QUEUE)%P)
       NULLIFY(PRAINFRAC_TOPRFZ(QUEUE)%P)
       NULLIFY(PFSQLF(QUEUE)%P)
       NULLIFY(PFSQIF(QUEUE)%P)
       NULLIFY(PFCQLNG(QUEUE)%P)
       NULLIFY(PFCQNNG(QUEUE)%P)
       NULLIFY(PFSQRF(QUEUE)%P)
       NULLIFY(PFSQSF(QUEUE)%P)
       NULLIFY(PFCQRNG(QUEUE)%P)
       NULLIFY(PFCQSNG(QUEUE)%P)
       NULLIFY(PFSQLTUR(QUEUE)%P)
       NULLIFY(PFSQITUR(QUEUE)%P)
       NULLIFY(PFPLSL(QUEUE)%P)
       NULLIFY(PFPLSN(QUEUE)%P)
       NULLIFY(PFHPSL(QUEUE)%P)
       NULLIFY(PFHPSN(QUEUE)%P)
       NULLIFY(TEND_LOC_T(QUEUE)%P)
       NULLIFY(TEND_LOC_Q(QUEUE)%P)
       NULLIFY(TEND_LOC_A(QUEUE)%P)
       NULLIFY(TEND_LOC_CLD(QUEUE)%P)
       NULLIFY(TEND_TMP_T(QUEUE)%P)
       NULLIFY(TEND_TMP_Q(QUEUE)%P)
       NULLIFY(TEND_TMP_A(QUEUE)%P)
       NULLIFY(TEND_TMP_CLD(QUEUE)%P)
    ENDDO

    !$acc exit data delete(PT)
    !$acc exit data delete(PQ)
    !$acc exit data delete(PVFA)
    !$acc exit data delete(PVFL)
    !$acc exit data delete(PVFI)
    !$acc exit data delete(PDYNA)
    !$acc exit data delete(PDYNL)
    !$acc exit data delete(PDYNI)
    !$acc exit data delete(PHRSW)
    !$acc exit data delete(PHRLW)
    !$acc exit data delete(PVERVEL)
    !$acc exit data delete(PAP)
    !$acc exit data delete(PAPH)
    !$acc exit data delete(PLSM)
    !$acc exit data delete(LDCUM)
    !$acc exit data delete(KTYPE)
    !$acc exit data delete(PLU)
    !$acc exit data delete(PLUDE)
    !$acc exit data delete(PSNDE)
    !$acc exit data delete(PMFU)
    !$acc exit data delete(PMFD)
    !$acc exit data delete(PA)
    !$acc exit data delete(PCLV)
    !$acc exit data delete(PSUPSAT)
    !$acc exit data delete(PLCRIT_AER)
    !$acc exit data delete(PICRIT_AER)
    !$acc exit data delete(PRE_ICE)
    !$acc exit data delete(PCCN)
    !$acc exit data delete(PNICE)
    !$acc exit data delete(PCOVPTOT)
    !$acc exit data delete(PRAINFRAC_TOPRFZ)
    !$acc exit data delete(PFSQLF)
    !$acc exit data delete(PFSQIF)
    !$acc exit data delete(PFCQLNG)
    !$acc exit data delete(PFCQNNG)
    !$acc exit data delete(PFSQRF)
    !$acc exit data delete(PFSQSF)
    !$acc exit data delete(PFCQRNG)
    !$acc exit data delete(PFCQSNG)
    !$acc exit data delete(PFSQLTUR)
    !$acc exit data delete(PFSQITUR)
    !$acc exit data delete(PFPLSL)
    !$acc exit data delete(PFPLSN)
    !$acc exit data delete(PFHPSL)
    !$acc exit data delete(PFHPSN)
    !$acc exit data delete(TEND_LOC_T)
    !$acc exit data delete(TEND_LOC_Q)
    !$acc exit data delete(TEND_LOC_A)
    !$acc exit data delete(TEND_LOC_CLD)
    !$acc exit data delete(TEND_TMP_T)
    !$acc exit data delete(TEND_TMP_Q)
    !$acc exit data delete(TEND_TMP_A)
    !$acc exit data delete(TEND_TMP_CLD)

    DEALLOCATE(PT)
    DEALLOCATE(PQ)
    DEALLOCATE(PVFA)
    DEALLOCATE(PVFL)
    DEALLOCATE(PVFI)
    DEALLOCATE(PDYNA)
    DEALLOCATE(PDYNL)
    DEALLOCATE(PDYNI)
    DEALLOCATE(PHRSW)
    DEALLOCATE(PHRLW)
    DEALLOCATE(PVERVEL)
    DEALLOCATE(PAP)
    DEALLOCATE(PAPH)
    DEALLOCATE(PLSM)
    DEALLOCATE(LDCUM)
    DEALLOCATE(KTYPE)
    DEALLOCATE(PLU)
    DEALLOCATE(PLUDE)
    DEALLOCATE(PSNDE)
    DEALLOCATE(PMFU)
    DEALLOCATE(PMFD)
    DEALLOCATE(PA)
    DEALLOCATE(PCLV)
    DEALLOCATE(PSUPSAT)
    DEALLOCATE(PLCRIT_AER)
    DEALLOCATE(PICRIT_AER)
    DEALLOCATE(PRE_ICE)
    DEALLOCATE(PCCN)
    DEALLOCATE(PNICE)
    DEALLOCATE(PCOVPTOT)
    DEALLOCATE(PRAINFRAC_TOPRFZ)
    DEALLOCATE(PFSQLF)
    DEALLOCATE(PFSQIF)
    DEALLOCATE(PFCQLNG)
    DEALLOCATE(PFCQNNG)
    DEALLOCATE(PFSQRF)
    DEALLOCATE(PFSQSF)
    DEALLOCATE(PFCQRNG)
    DEALLOCATE(PFCQSNG)
    DEALLOCATE(PFSQLTUR)
    DEALLOCATE(PFSQITUR)
    DEALLOCATE(PFPLSL)
    DEALLOCATE(PFPLSN)
    DEALLOCATE(PFHPSL)
    DEALLOCATE(PFHPSN)
    DEALLOCATE(TEND_LOC_T)
    DEALLOCATE(TEND_LOC_Q)
    DEALLOCATE(TEND_LOC_A)
    DEALLOCATE(TEND_LOC_CLD)
    DEALLOCATE(TEND_TMP_T)
    DEALLOCATE(TEND_TMP_Q)
    DEALLOCATE(TEND_TMP_A)
    DEALLOCATE(TEND_TMP_CLD)

  END SUBROUTINE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC

END MODULE CLOUDSC_DRIVER_GPU_SCC_FIELD_ASYNC_MOD
