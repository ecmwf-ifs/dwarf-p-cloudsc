! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_GLOBAL_ATLAS_STATE_MOD
  ! Driver module to manage the setup and teardown of the dwarf memory state
  USE PARKIND1,  ONLY : JPIM, JPRB
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_ATLAS_MOD, ONLY: LOADVAR_ATLAS, LOADSTATE_ATLAS
  USE VALIDATE_ATLAS_MOD, ONLY: VALIDATEVAR_ATLAS, VALIDATESTATE_ATLAS
  USE CLOUDSC_MPI_MOD, ONLY: IRANK

  USE ATLAS_MODULE
  USE, INTRINSIC :: ISO_C_BINDING
  USE ATLAS_FUNCTIONSPACE_BLOCKSTRUCTUREDCOLUMNS_MODULE
!  USE ATLAS_MULTIFIELD_MODULE

  IMPLICIT NONE

  TYPE VAR3D_PTR
      REAL(KIND=JPRB), POINTER :: PTR(:,:,:)
  END TYPE
  TYPE VAR2D_PTR
      REAL(KIND=JPRB), POINTER :: PTR(:,:)
  END TYPE

  CHARACTER(LEN=16), PARAMETER, DIMENSION(37) :: IN_VAR_NAMES = (/ &
      "PLCRIT_AER      ", "PICRIT_AER      ", "PRE_ICE         ", "PCCN            ", "PNICE           ", &
      "PT              ", "PQ              ", "PVFA            ", "PVFL            ", "PVFI            ", &
      "PDYNA           ", "PDYNL           ", "PDYNI           ", "PHRSW           ", "PHRLW           ", &
      "PVERVEL         ", "PAP             ", "PLU             ", "PLUDE           ", "PSNDE           ", &
      "PMFU            ", "PMFD            ", "PA              ", "PSUPSAT         ", "TENDENCY_CML_T  ", &
      "TENDENCY_CML_A  ", "TENDENCY_CML_Q  ", "TENDENCY_TMP_T  ", "TENDENCY_TMP_A  ", "TENDENCY_TMP_Q  ", &
      "PLSM            ", "LDCUM           ", "KTYPE           ", "PAPH            ", "PCLV            ", &
      "TENDENCY_CML_CLD", "TENDENCY_TMP_CLD" /)
  CHARACTER(LEN=16), PARAMETER, DIMENSION(20) :: OUT_VAR_NAMES = (/ &
      "PFSQLF          ", "PFSQIF          ", "PFCQLNG         ", "PFCQNNG         ", "PFSQRF          ", &
      "PFSQSF          ", "PFCQRNG         ", "PFCQSNG         ", "PFSQLTUR        ", "PFSQITUR        ", &
      "PFPLSL          ", "PFPLSN          ", "PFHPSL          ", "PFHPSN          ", "PCOVPTOT        ", &
      "TENDENCY_LOC_T  ", "TENDENCY_LOC_A  ", "TENDENCY_LOC_Q  ", "PRAINFRAC_TOPRFZ", "TENDENCY_LOC_CLD" /) 

  TYPE CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK_VIEW
    ! Input field variables and tendencies
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLCRIT_AER(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PICRIT_AER(:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRE_ICE(:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCCN(:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PNICE(:,:)    ! ice number concentration (cf. CCN)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PT(:,:)       ! T at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PQ(:,:)       ! Q at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFA(:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFL(:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFI(:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNA(:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNL(:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNI(:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRSW(:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRLW(:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVERVEL(:,:)  ! Vertical velocity
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAP(:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLU(:,:)      ! Conv. condensate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLUDE(:,:)    ! Conv. detrained water 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSNDE(:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFU(:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFD(:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PA(:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSUPSAT(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_CML_T(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_CML_A(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_CML_Q(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_TMP_T(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_TMP_A(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_TMP_Q(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLSM(:)       ! Land fraction (0-1) 
    LOGICAL,         POINTER, CONTIGUOUS :: LDCUM(:)      ! Convection active
    INTEGER,         POINTER, CONTIGUOUS :: KTYPE(:)      ! Convection type 0,1,2
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAPH(:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCLV(:,:,:) 
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_CML_CLD(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_TMP_CLD(:,:)

    ! Output fields used for validation
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLF(:,:)   ! Flux of liquid
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQIF(:,:)   ! Flux of ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQLNG(:,:)  ! -ve corr for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQNNG(:,:)  ! -ve corr for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQRF(:,:)   ! Flux diagnostics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQSF(:,:)   ! for DDH, generic
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQRNG(:,:)  ! rain
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQSNG(:,:)  ! snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLTUR(:,:) ! liquid flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQITUR(:,:) ! ice flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSL(:,:)   ! liq+rain sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSN(:,:)   ! ice+snow sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSL(:,:)   ! Enthalpy flux for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSN(:,:)   ! Enthalpy flux for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCOVPTOT(:,:) ! Precip fraction
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRAINFRAC_TOPRFZ(:) 

    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_LOC_T(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_LOC_A(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_LOC_Q(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: TENDENCY_LOC_CLD(:,:)

    CONTAINS
    PROCEDURE :: GET_BLOCK => CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK
  END TYPE CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK_VIEW

  TYPE CLOUDSC_GLOBAL_ATLAS_STATE
    ! Memory state containing raw fields annd tendencies for CLOUDSC dwarf
    !
    ! Note that the global state has an additional outermost block
    ! dimension allocated for each field variable.
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX 
    LOGICAL                              :: LDSLPHY 
    LOGICAL                              :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_GLOBAL_ATLAS_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_GLOBAL_ATLAS_STATE_VALIDATE
  END TYPE CLOUDSC_GLOBAL_ATLAS_STATE

CONTAINS

  SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK(SELF, FSET, IBLK)
    CLASS(CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK_VIEW), INTENT(INOUT) :: SELF
    TYPE(ATLAS_FIELDSET), INTENT(INOUT) :: FSET
    INTEGER, INTENT(IN) :: IBLK

    REAL(KIND=JPRB), POINTER :: TMP3D(:,:,:)

    ! input
    CALL FSET%DATA(1, SELF%PLCRIT_AER, IBLK)
    CALL FSET%DATA(2, SELF%PICRIT_AER, IBLK)
    CALL FSET%DATA(3, SELF%PRE_ICE, IBLK)
    CALL FSET%DATA(4, SELF%PCCN, IBLK)
    CALL FSET%DATA(5, SELF%PNICE, IBLK)
    CALL FSET%DATA(6, SELF%PT, IBLK)
    CALL FSET%DATA(7, SELF%PQ, IBLK)
    CALL FSET%DATA(8, SELF%PVFA, IBLK)
    CALL FSET%DATA(9, SELF%PVFL, IBLK)
    CALL FSET%DATA(10, SELF%PVFI, IBLK)
    CALL FSET%DATA(11, SELF%PDYNA, IBLK)
    CALL FSET%DATA(12, SELF%PDYNL, IBLK)
    CALL FSET%DATA(13, SELF%PDYNI, IBLK)
    CALL FSET%DATA(14, SELF%PHRSW, IBLK)
    CALL FSET%DATA(15, SELF%PHRLW, IBLK)
    CALL FSET%DATA(16, SELF%PVERVEL, IBLK)
    CALL FSET%DATA(17, SELF%PAP, IBLK)
    CALL FSET%DATA(18, SELF%PLU, IBLK)
    CALL FSET%DATA(19, SELF%PLUDE, IBLK)
    CALL FSET%DATA(20, SELF%PSNDE, IBLK)
    CALL FSET%DATA(21, SELF%PMFU, IBLK)
    CALL FSET%DATA(22, SELF%PMFD, IBLK)
    CALL FSET%DATA(23, SELF%PA, IBLK)
    CALL FSET%DATA(24, SELF%PSUPSAT, IBLK)
    CALL FSET%DATA(25, SELF%TENDENCY_CML_T, IBLK)
    CALL FSET%DATA(26, SELF%TENDENCY_CML_A, IBLK)
    CALL FSET%DATA(27, SELF%TENDENCY_CML_Q, IBLK)
    CALL FSET%DATA(28, SELF%TENDENCY_TMP_T, IBLK)
    CALL FSET%DATA(29, SELF%TENDENCY_TMP_A, IBLK)
    CALL FSET%DATA(30, SELF%TENDENCY_TMP_Q, IBLK)
    CALL FSET%DATA(31, SELF%PLSM, IBLK)
    CALL FSET%DATA(32, SELF%LDCUM, IBLK)
    CALL FSET%DATA(33, SELF%KTYPE, IBLK)
    CALL FSET%DATA(34, SELF%PAPH, IBLK)
    CALL FSET%DATA(35, SELF%PCLV, IBLK)
    CALL FSET%DATA(36, SELF%TENDENCY_CML_CLD, IBLK)
    CALL FSET%DATA(37, SELF%TENDENCY_TMP_CLD, IBLK)

    ! output
    CALL FSET%DATA(38, SELF%PFSQLF, IBLK)
    CALL FSET%DATA(39, SELF%PFSQIF, IBLK)
    CALL FSET%DATA(40, SELF%PFCQLNG, IBLK)
    CALL FSET%DATA(41, SELF%PFCQNNG, IBLK)
    CALL FSET%DATA(42, SELF%PFSQRF, IBLK)
    CALL FSET%DATA(43, SELF%PFSQSF, IBLK)
    CALL FSET%DATA(44, SELF%PFCQRNG, IBLK)
    CALL FSET%DATA(45, SELF%PFCQSNG, IBLK)
    CALL FSET%DATA(46, SELF%PFSQLTUR, IBLK)
    CALL FSET%DATA(47, SELF%PFSQITUR, IBLK)
    CALL FSET%DATA(48, SELF%PFPLSL, IBLK)
    CALL FSET%DATA(49, SELF%PFPLSN, IBLK)
    CALL FSET%DATA(50, SELF%PFHPSL, IBLK)
    CALL FSET%DATA(51, SELF%PFHPSN, IBLK)
    CALL FSET%DATA(52, SELF%PCOVPTOT, IBLK)
    CALL FSET%DATA(53, SELF%TENDENCY_LOC_T, IBLK)
    CALL FSET%DATA(54, SELF%TENDENCY_LOC_A, IBLK)
    CALL FSET%DATA(55, SELF%TENDENCY_LOC_Q, IBLK)
    CALL FSET%DATA(56, SELF%PRAINFRAC_TOPRFZ, IBLK)
    CALL FSET%DATA(57, SELF%TENDENCY_LOC_CLD, IBLK)
  END SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_BLOCK

  SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_LOAD(SELF, FSET, FSPACE, NPROMA, NGPTOTG)
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_GLOBAL_ATLAS_STATE) :: SELF
    TYPE(ATLAS_FIELDSET), INTENT(INOUT) :: FSET
    TYPE(ATLAS_FUNCTIONSPACE_BLOCKSTRUCTUREDCOLUMNS), INTENT(INOUT) :: FSPACE
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOTG

    TYPE(ATLAS_STRUCTUREDGRID) :: GRID
    !TYPE(ATLAS_MULTIFIELD) :: MULTIFIELD_IN, MULTIFIELD_OUT
    INTEGER(KIND=JPIM) :: KLON, IVAR, B
    REAL(KIND=JPRB), POINTER :: TMP4D(:,:,:,:)
    REAL(KIND=JPRB), POINTER :: TMP3D(:,:,:)
    REAL(KIND=JPRB), POINTER :: TMP2D(:,:)
    TYPE(ATLAS_FIELD) :: FIELD
    TYPE(ATLAS_CONFIG) :: CONFIG
    TYPE(ATLAS_CONFIG), DIMENSION(24) :: IN_MFIELD_CONFIG ! the last five variables are special and added through FieldSet
    TYPE(ATLAS_CONFIG), DIMENSION(14) :: OUT_MFIELD_CONFIG ! the last two variables are special and added through FieldSet
    INTEGER :: INVAR_SIZE, OUTVAR_SIZE
    LOGICAL :: LMULTIFIELD
    CHARACTER(len=8) :: CENV, FPREC
    INTEGER :: CENV_LEN
    TYPE(ATLAS_TRACE) :: TRACE, TRACE_IO

    TRACE = ATLAS_TRACE("cloudsc_global_atlas_state_mod.F90", __LINE__, &
        & "CLOUDSC_GLOBAL_ATLAS_STATE_LOAD")

    LMULTIFIELD = .FALSE.
    CALL GET_ENVIRONMENT_VARIABLE("CLOUDSC_ATLAS_MULTIFIELD",CENV,CENV_LEN)
    IF (CENV_LEN > 0 ) THEN
      IF( TRIM(CENV) == "0" .OR. TRIM(CENV) == "OFF" .OR. TRIM(CENV) == "FALSE" ) THEN
        LMULTIFIELD = .FALSE.
      ENDIF
    ENDIF

    IF (IRANK == 0) THEN
      PRINT *, " LMULTIFIELD: ", LMULTIFIELD
    ENDIF

    CALL INPUT_INITIALIZE(NAME='input')

    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    GRID = ATLAS_REGULARLONLATGRID(NGPTOTG, 1)
    FSPACE = ATLAS_FUNCTIONSPACE_BLOCKSTRUCTUREDCOLUMNS(GRID, LEVELS=SELF%KLEV, NPROMA=NPROMA, HALO=0)
    SELF%NBLOCKS = FSPACE%NBLKS()

    ! create multifield
    CONFIG = ATLAS_CONFIG()
    CALL CONFIG%SET("type", "MultiFieldCreatorIFS")
    CALL CONFIG%SET("nproma", NPROMA)
    CALL CONFIG%SET("ngptot", FSPACE%SIZE())
    WRITE (FPREC,"(A4,I2)") "real", 8*jprb
    CALL CONFIG%SET("datatype", TRIM(FPREC))
    
    INVAR_SIZE = SIZE(IN_VAR_NAMES) - 7
    IF (LMULTIFIELD) THEN
      ! input multifield on model levels, i.e. LEVELS = FSPACE%LEVELS() = SELF%KLEV
      DO IVAR = 1, INVAR_SIZE
          IN_MFIELD_CONFIG(IVAR) = ATLAS_CONFIG()
          CALL IN_MFIELD_CONFIG(IVAR)%SET("name", TRIM(IN_VAR_NAMES(IVAR)))
      END DO
      CALL CONFIG%SET("nlev", FSPACE%LEVELS())
      CALL CONFIG%SET("fields", IN_MFIELD_CONFIG)
      DO IVAR = 1, INVAR_SIZE
          CALL IN_MFIELD_CONFIG(IVAR)%FINAL()
      END DO
!      MULTIFIELD_IN = atlas_MultiField(CONFIG)
!      CALL FSET%ADD(MULTIFIELD_IN%FIELDSET()) 
!      CALL MULTIFIELD_IN%FINAL()
    ELSE
      DO IVAR = 1, INVAR_SIZE
          CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME=TRIM(IN_VAR_NAMES(IVAR)),   KIND=ATLAS_REAL(JPRB)))
          FIELD = FSET%FIELD(TRIM(IN_VAR_NAMES(IVAR)))
      !    CALL FIELD%ALLOCATE_DEVICE()
      END DO
    ENDIF

    ! special input variables
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PLSM",   KIND=ATLAS_REAL(JPRB),    LEVELS=0))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="LDCUM",  KIND=ATLAS_LOGICAL(),     LEVELS=0))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="KTYPE",  KIND=ATLAS_INTEGER(JPIM), LEVELS=0))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PAPH",   KIND=ATLAS_REAL(JPRB),    LEVELS=SELF%KLEV+1))
    !CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PEXTRA", KIND=ATLAS_REAL(JPRB),    VARIABLES=MAX(1,SELF%KFLDX)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PCLV",   KIND=ATLAS_REAL(JPRB),    VARIABLES=MAX(1,NCLV)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_CML_CLD', KIND=ATLAS_REAL(JPRB), VARIABLES=NCLV))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_TMP_CLD', KIND=ATLAS_REAL(JPRB), VARIABLES=NCLV))

    IF (LMULTIFIELD) THEN
        ! output multifield on model interfaces, i.e. LEVELS = FSPACE%LEVELS() + 1 = SELF%KLEV + 1
        DO IVAR = 1, SIZE(OUT_VAR_NAMES) - 2
            OUT_MFIELD_CONFIG(IVAR) = ATLAS_CONFIG()
            CALL OUT_MFIELD_CONFIG(IVAR)%SET("name", TRIM(OUT_VAR_NAMES(IVAR)))
            CALL OUT_MFIELD_CONFIG(IVAR)%SET("levels", SELF%KLEV+1)
        END DO
        CALL CONFIG%SET("nlev", 1 + FSPACE%LEVELS())
        CALL CONFIG%SET("fields", OUT_MFIELD_CONFIG)
        DO IVAR = 1, SIZE(OUT_VAR_NAMES) - 2
            CALL OUT_MFIELD_CONFIG(IVAR)%FINAL()
        END DO
!        MULTIFIELD_OUT = atlas_MultiField(CONFIG)
!        CALL FSET%ADD(MULTIFIELD_OUT%FIELDSET()) 
!        CALL MULTIFIELD_OUT%FINAL()
    ELSE
        DO IVAR = 1, SIZE(OUT_VAR_NAMES) - 6
            PRINT *, "crating field : ", TRIM(OUT_VAR_NAMES(IVAR))
            CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME=TRIM(OUT_VAR_NAMES(IVAR)),   KIND=ATLAS_REAL(JPRB), LEVELS=SELF%KLEV+1))
        END DO
    ENDIF

    ! special output variables
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PCOVPTOT", KIND=ATLAS_REAL(JPRB)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_LOC_T', KIND=ATLAS_REAL(JPRB)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_LOC_A', KIND=ATLAS_REAL(JPRB)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_LOC_Q', KIND=ATLAS_REAL(JPRB)))
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME="PRAINFRAC_TOPRFZ", KIND=ATLAS_REAL(JPRB), LEVELS=0))
    FIELD = FSET%FIELD(TRIM("PRAINFRAC_TOPRFZ"))
    CALL FIELD%DATA(TMP2D)
    CALL FSET%ADD(FSPACE%CREATE_FIELD(NAME='TENDENCY_LOC_CLD', KIND=ATLAS_REAL(JPRB), VARIABLES=NCLV))

    DO IVAR = 1, SIZE(IN_VAR_NAMES)
        CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM(IN_VAR_NAMES(IVAR)), KLON, NGPTOTG)
    ENDDO
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_CML_T"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_CML_A"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_CML_Q"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_CML_CLD"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_TMP_T"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_TMP_A"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_TMP_Q"), KLON, NGPTOTG)
    CALL LOADVAR_ATLAS(FSET, FSPACE, TRIM("TENDENCY_TMP_CLD"), KLON, NGPTOTG)
    !CALL LOADSTATE_ATLAS(FSET, 'TENDENCY_CML', KLON, NGPTOTG)
    !CALL LOADSTATE_ATLAS(FSET, 'TENDENCY_TMP', KLON, NGPTOTG)

    ! Output fields are simply zero'd
    DO IVAR = 1, SIZE(OUT_VAR_NAMES) - 2
        FIELD = FSET%FIELD(TRIM(OUT_VAR_NAMES(IVAR)))
        CALL FIELD%DATA(TMP3D)
        PRINT *, " --- doing ", FIELD%NAME()
        !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
        DO B=1, SELF%NBLOCKS
           TMP3D(:,:,B) = 0.0_JPRB
        END DO
        !$omp end parallel do
    ENDDO

    FIELD = FSET%FIELD(TRIM("PRAINFRAC_TOPRFZ"))
    CALL FIELD%DATA(TMP2D)
    PRINT *, " --- doing 2d ", FIELD%NAME()
    !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, SELF%NBLOCKS
       TMP2D(:,B) = 0.0_JPRB
    END DO
    !$OMP END PARALLEL DO

    PRINT *, " --- done doing 2d ", FIELD%NAME()
    FIELD = FSET%FIELD(TRIM("TENDENCY_TMP_CLD"))
    CALL FIELD%DATA(TMP4D)
    PRINT *, " --- doing 4d ", FIELD%NAME()
    !$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, SELF%NBLOCKS
       TMP4D(:,:,:,B) = 0.0_JPRB
    END DO
    !$OMP END PARALLEL DO

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

    print *, "check 111"

    CALL FIELD%FINAL()
    CALL CONFIG%FINAL()
    CALL GRID%FINAL()
    CALL TRACE%FINAL()
    print *, "check 112"
  END SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_LOAD

  SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_VALIDATE(SELF, FSET, FSPACE, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_GLOBAL_ATLAS_STATE) :: SELF
    TYPE(ATLAS_FIELDSET), INTENT(INOUT) :: FSET
    TYPE(ATLAS_FUNCTIONSPACE_BLOCKSTRUCTUREDCOLUMNS), INTENT(IN) :: FSPACE
    INTEGER(KIND=JPIM), INTENT(IN) :: NGPTOTG

    TYPE(ATLAS_TRACE) :: TRACE
    INTEGER(KIND=JPIM) :: KLON, IVAR

    TRACE = ATLAS_TRACE("cloudsc_global_atlas_state_mod.F90", __LINE__, "VALIDATE", "VALIDATE")
    CALL INPUT_INITIALIZE(NAME='reference')
    CALL LOAD_SCALAR('KLON', KLON)
    print *, "KLON = ", KLON

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF


    ! Actual variable validation
    CALL VALIDATEVAR_ATLAS(FSET, FSPACE, 'PLUDE', KLON, NGPTOTG)
    DO IVAR = 1, SIZE(OUT_VAR_NAMES)
        CALL VALIDATEVAR_ATLAS(FSET, FSPACE, TRIM(OUT_VAR_NAMES(IVAR)), KLON, NGPTOTG)
    ENDDO
    CALL VALIDATESTATE_ATLAS(FSET, FSPACE, 'TENDENCY_LOC', KLON, NGPTOTG)
    CALL INPUT_FINALIZE()
    CALL TRACE%FINAL()
  END SUBROUTINE CLOUDSC_GLOBAL_ATLAS_STATE_VALIDATE

END MODULE CLOUDSC_GLOBAL_ATLAS_STATE_MOD
