! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE TIMER_MOD
  USE PARKIND1, ONLY: JPIM, JPRB, JPIB, JPRD

#ifdef _OPENMP
use omp_lib
#else
#define omp_get_num_threads() 1
#define omp_get_max_threads() 1
#define omp_get_thread_num() 0
#endif

  USE CLOUDSC_MPI_MOD, ONLY: IRANK, NUMPROC, CLOUDSC_MPI_GATHER_INT

  IMPLICIT NONE

  ! Reference flop count from operations model flop rate estimation
  ! IBM P7 HPM flop count for 100 points at L137
  REAL(KIND=JPRD), PARAMETER :: ZHPM = 12482329.0_JPRD

  TYPE PERFORMANCE_TIMER
    INTEGER(KIND=JPIM) :: NUMOMP

    ! Application-level counters for the full parallel loop
    REAL(KIND=JPRD) :: TSTART, TEND

    ! Thread-level timing and counter arrays
    REAL(KIND=JPRD), ALLOCATABLE :: TTHREAD(:)
    REAL(KIND=JPRD), ALLOCATABLE :: TTHREADTEMP(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: COREID(:), ICALLS(:), IGPC(:)

    ! ENERGY, POWER, POWER_TOTAL, POWER_MAX, POWER_COUNT

  CONTAINS
    PROCEDURE :: START => PERFORMANCE_TIMER_START
    PROCEDURE :: END => PERFORMANCE_TIMER_END
    PROCEDURE :: THREAD_START => PERFORMANCE_TIMER_THREAD_START
    PROCEDURE :: THREAD_END => PERFORMANCE_TIMER_THREAD_END
    PROCEDURE :: THREAD_ACC_START => PERFORMANCE_TIMER_THREAD_ACC_START
    PROCEDURE :: THREAD_ACC_END => PERFORMANCE_TIMER_THREAD_ACC_END
    PROCEDURE :: THREAD_LOG => PERFORMANCE_TIMER_THREAD_LOG

    PROCEDURE :: PRINT_PERFORMANCE => PERFORMANCE_TIMER_PRINT_PERFORMANCE
  END TYPE PERFORMANCE_TIMER

#include "mycpu.intfb.h"

CONTAINS

  FUNCTION GET_THREAD_NUM()
    ! Wrapper toget OpenMP thread ID
    INTEGER(KIND=JPIM) :: GET_THREAD_NUM

    GET_THREAD_NUM = omp_get_thread_num()
  END FUNCTION GET_THREAD_NUM

  FUNCTION FTIMER()
    REAL(KIND=JPRD) :: FTIMER
    INTEGER(KIND=JPIB) :: T, RATE

    CALL SYSTEM_CLOCK(T,COUNT_RATE=RATE)
    FTIMER = REAL(T, KIND(FTIMER)) / REAL(RATE, KIND(FTIMER))
  END FUNCTION FTIMER

  SUBROUTINE PERFORMANCE_TIMER_START(SELF, NUMOMP)
    ! Start the global timer and allocate thread-local arrays
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NUMOMP

    SELF%NUMOMP = NUMOMP
    ALLOCATE(SELF%TTHREAD(0:NUMOMP-1))
    ALLOCATE(SELF%TTHREADTEMP(0:NUMOMP-1))
    ALLOCATE(SELF%COREID(0:NUMOMP-1))
    ALLOCATE(SELF%ICALLS(0:NUMOMP-1))
    ALLOCATE(SELF%IGPC(0:NUMOMP-1))
    
    SELF%TTHREAD = 0
    SELF%ICALLS(:) = 0
    SELF%IGPC(:) = 0

    SELF%TSTART = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_START

  SUBROUTINE PERFORMANCE_TIMER_END(SELF)
    ! Finalize the global timer and thread-local arrays
    CLASS(PERFORMANCE_TIMER) :: SELF

    SELF%TEND = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_END

  SUBROUTINE PERFORMANCE_TIMER_THREAD_START(SELF, TID)
    ! Start the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%COREID(TID) = mycpu()
    SELF%TTHREAD(TID) = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_START

  SUBROUTINE PERFORMANCE_TIMER_THREAD_END(SELF, TID)
    ! Finalize the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%TTHREAD(TID) = FTIMER() - SELF%TTHREAD(TID)
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_END


  SUBROUTINE PERFORMANCE_TIMER_THREAD_ACC_START(SELF, TID)
    ! Start the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%COREID(TID) = mycpu()
    SELF%TTHREADTEMP(TID) = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_ACC_START

  SUBROUTINE PERFORMANCE_TIMER_THREAD_ACC_END(SELF, TID)
    ! Finalize the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%TTHREAD(TID) = SELF%TTHREAD(TID) + (FTIMER() - SELF%TTHREADTEMP(TID))
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_ACC_END

  
  SUBROUTINE PERFORMANCE_TIMER_THREAD_LOG(SELF, TID, IGPC)
    ! Finalize the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID, IGPC

    SELF%ICALLS(TID) = SELF%ICALLS(TID) + 1
    SELF%IGPC(TID) = SELF%IGPC(TID) + IGPC
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_LOG

  SUBROUTINE PERFORMANCE_TIMER_PRINT_PERFORMANCE(SELF, NPROMA, NGPBLKS, NGPTOT)
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPBLKS, NGPTOT

    REAL(KIND=JPRD) :: TLOC, TDIFF
    REAL(KIND=JPRB) :: ZFRAC, ZMFLOPS, ZTHRPUT
    INTEGER(KIND=JPIM) :: TID, IPROC
    INTEGER :: ISENDBUF(6,0:SELF%NUMOMP), IRECVBUF(6,0:SELF%NUMOMP,0:NUMPROC-1)

1000  format(1x,5a10,1x,a4,' : ',3a10)
1001  format(1x,5i10,1x,i4,' : ',3i10,:,' @ rank#',i0,':core#',i0)
1002  format(1x,5i10,1x,i4,' : ',3i10,  ' : TOTAL @ rank#', i0)
1003  format(1x,i4,' x',i4,4i10,1x,i4,' : ',3i10,' : TOTAL')
1004  format(1x,'Reference MFLOP count for 100 columns :',1x,f12.8)
    DO TID=0, SELF%NUMOMP-1
      TLOC = SELF%TTHREAD(TID)
      ZFRAC = REAL(SELF%IGPC(TID),JPRB)/REAL(NGPTOT,JPRB)
      IF (TLOC > 0.0_JPRD) THEN
        ZTHRPUT = REAL(NGPTOT,JPRB)/TLOC
        ZMFLOPS = 1.0E-06_JPRB * ZFRAC * ZHPM * (REAL(NGPTOT,JPRB)/REAL(100,JPRB))/TLOC
      ELSE
        ZTHRPUT = 0.0_JPRB
        ZMFLOPS = 0.0_JPRB
      ENDIF
      ISENDBUF(1,TID) = SELF%COREID(TID)
      ISENDBUF(2,TID) = SELF%IGPC(TID)
      ISENDBUF(3,TID) = SELF%ICALLS(TID)
      ISENDBUF(4,TID) = INT(TLOC*1000.0_JPRB)
      ISENDBUF(5,TID) = INT(ZMFLOPS)
      ISENDBUF(6,TID) = INT(ZTHRPUT)
    ENDDO
    TDIFF = SELF%TEND - SELF%TSTART
    ZFRAC = 1.0_JPRB
    IF (TDIFF > 0.0_JPRB) THEN
      ZMFLOPS = 1.0E-06_JPRB * ZFRAC * ZHPM * (REAL(NGPTOT,JPRB)/REAL(100,JPRB))/TDIFF
      ZTHRPUT = REAL(NGPTOT,JPRB)/TDIFF
    ELSE
      ZMFLOPS = 0.0_JPRB
      ZTHRPUT = 0.0_JPRB
    ENDIF
    ISENDBUF(1,SELF%NUMOMP) = NGPTOT
    ISENDBUF(2,SELF%NUMOMP) = SUM(SELF%IGPC)
    ISENDBUF(3,SELF%NUMOMP) = NGPBLKS
    ISENDBUF(4,SELF%NUMOMP) = INT(TDIFF*1000.0_JPRB)
    ISENDBUF(5,SELF%NUMOMP) = INT(ZMFLOPS)
    ISENDBUF(6,SELF%NUMOMP) = INT(ZTHRPUT)

    CALL CLOUDSC_MPI_GATHER_INT(ISENDBUF, 6 * (SELF%NUMOMP + 1), IRECVBUF, 6 * (SELF%NUMOMP+1), 0)

    IF (IRANK == 0) THEN
      WRITE(0,1004) 1.0E-06_JPRB * ZHPM
      WRITE(0,1000) 'NUMOMP','NGPTOT','#GP-cols','#BLKS','NPROMA','tid#','Time(msec)','MFlops/s','col/s'
      DO IPROC=0, NUMPROC-1
        DO TID=0, SELF%NUMOMP-1
          WRITE(0,1001) SELF%NUMOMP, IRECVBUF(1,SELF%NUMOMP,IPROC), IRECVBUF(2,TID,IPROC), &
                & IRECVBUF(3,TID,IPROC), NPROMA, TID, IRECVBUF(4,TID,IPROC), IRECVBUF(5,TID,IPROC), &
                & IRECVBUF(6,TID,IPROC), IPROC, IRECVBUF(1,TID,IPROC)
        ENDDO
        ZMFLOPS = 1.0E-06_JPRB * ZFRAC * ZHPM * (REAL(IRECVBUF(5,SELF%NUMOMP,IPROC),JPRB)/REAL(100,JPRB))
        WRITE(0,1002) SELF%NUMOMP, IRECVBUF(1,SELF%NUMOMP,IPROC), IRECVBUF(2,SELF%NUMOMP,IPROC), &
              & IRECVBUF(3,SELF%NUMOMP,IPROC), NPROMA, -1, IRECVBUF(4,SELF%NUMOMP,IPROC), &
              & IRECVBUF(5,SELF%NUMOMP,IPROC), IRECVBUF(6,SELF%NUMOMP,IPROC), IPROC
      ENDDO
      WRITE(0,1003) NUMPROC, SELF%NUMOMP, SUM(IRECVBUF(1,SELF%NUMOMP,:)), &
            & SUM(IRECVBUF(2,SELF%NUMOMP,:)), SUM(IRECVBUF(3,SELF%NUMOMP,:)), &
            & NPROMA, -1, MAXVAL(IRECVBUF(4,SELF%NUMOMP,:)), SUM(IRECVBUF(5,SELF%NUMOMP,:)), &
            & SUM(IRECVBUF(6,SELF%NUMOMP,:))
    ENDIF

  END SUBROUTINE PERFORMANCE_TIMER_PRINT_PERFORMANCE

END MODULE TIMER_MOD
