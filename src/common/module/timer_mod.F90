MODULE TIMER_MOD
  USE PARKIND1, ONLY: JPIM, JPRB, JPIB, JPRD

#ifdef _OPENMP
use omp_lib
#else
#define omp_get_num_threads() 1
#define omp_get_max_threads() 1
#define omp_get_thread_num() 0
#endif

  USE CLOUDSC_MPI_MOD, ONLY: IRANK, NUMPROC, CLOUDSC_MPI_GATHER_INT

  IMPLICIT NONE

  ! Reference flop count from operations model flop rate estimation
  ! IBM P7 HPM flop count for 100 points at L137
  REAL(KIND=JPRD), PARAMETER :: ZHPM = 12482329.0_JPRD

  TYPE PERFORMANCE_TIMER
    INTEGER(KIND=JPIM) :: NUMOMP

    ! Application-level counters for the full parallel loop
    REAL(KIND=JPRD) :: TSTART, TEND

    ! Thread-level timing and counter arrays
    REAL(KIND=JPRD), ALLOCATABLE :: TTHREAD(:)
    INTEGER(KIND=JPIM), ALLOCATABLE :: COREID(:), ICALLS(:), IGPC(:)

    ! ENERGY, POWER, POWER_TOTAL, POWER_MAX, POWER_COUNT

  CONTAINS
    PROCEDURE :: START => PERFORMANCE_TIMER_START
    PROCEDURE :: END => PERFORMANCE_TIMER_END
    PROCEDURE :: THREAD_START => PERFORMANCE_TIMER_THREAD_START
    PROCEDURE :: THREAD_END => PERFORMANCE_TIMER_THREAD_END
    PROCEDURE :: THREAD_LOG => PERFORMANCE_TIMER_THREAD_LOG

    PROCEDURE :: PRINT_PERFORMANCE => PERFORMANCE_TIMER_PRINT_PERFORMANCE
  END TYPE PERFORMANCE_TIMER

#include "mycpu.intfb.h"

CONTAINS

  FUNCTION GET_THREAD_NUM()
    ! Wrapper toget OpenMP thread ID
    INTEGER(KIND=JPIM) :: GET_THREAD_NUM

    GET_THREAD_NUM = omp_get_thread_num()
  END FUNCTION GET_THREAD_NUM

  FUNCTION FTIMER()
    REAL(KIND=JPRD) :: FTIMER
    INTEGER(KIND=JPIB) :: T, RATE

    CALL SYSTEM_CLOCK(T,COUNT_RATE=RATE)
    FTIMER = REAL(T, KIND(FTIMER)) / REAL(RATE, KIND(FTIMER))
  END FUNCTION FTIMER

  SUBROUTINE PERFORMANCE_TIMER_START(SELF, NUMOMP)
    ! Start the global timer and allocate thread-local arrays
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NUMOMP

    SELF%NUMOMP = NUMOMP
    ALLOCATE(SELF%TTHREAD(0:NUMOMP-1))
    ALLOCATE(SELF%COREID(0:NUMOMP-1))
    ALLOCATE(SELF%ICALLS(0:NUMOMP-1))
    ALLOCATE(SELF%IGPC(0:NUMOMP-1))

    SELF%ICALLS(:) = 0
    SELF%IGPC(:) = 0

    SELF%TSTART = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_START

  SUBROUTINE PERFORMANCE_TIMER_END(SELF)
    ! Finalize the global timer and thread-local arrays
    CLASS(PERFORMANCE_TIMER) :: SELF

    SELF%TEND = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_END

  SUBROUTINE PERFORMANCE_TIMER_THREAD_START(SELF, TID)
    ! Start the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%COREID(TID) = mycpu()
    SELF%TTHREAD(TID) = FTIMER()
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_START

  SUBROUTINE PERFORMANCE_TIMER_THREAD_END(SELF, TID)
    ! Finalize the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID

    SELF%TTHREAD(TID) = FTIMER() - SELF%TTHREAD(TID)
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_END

  SUBROUTINE PERFORMANCE_TIMER_THREAD_LOG(SELF, TID, IGPC)
    ! Finalize the thread-local timer
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: TID, IGPC

    SELF%ICALLS(TID) = SELF%ICALLS(TID) + 1
    SELF%IGPC(TID) = SELF%IGPC(TID) + IGPC
  END SUBROUTINE PERFORMANCE_TIMER_THREAD_LOG

  SUBROUTINE PERFORMANCE_TIMER_PRINT_PERFORMANCE(SELF, NPROMA, NGPBLKS, NGPTOT)
    CLASS(PERFORMANCE_TIMER) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPBLKS, NGPTOT

    REAL(KIND=JPRD) :: TLOC, TDIFF
    REAL(KIND=JPRB) :: ZFRAC, ZMFLOPS
    INTEGER(KIND=JPIM) :: TID, IPROC
    INTEGER :: ISENDBUF(5,0:SELF%NUMOMP), IRECVBUF(5,0:SELF%NUMOMP,0:NUMPROC-1)

1000  format(1x,5a10,1x,a4,' : ',2a10)
1001  format(1x,5i10,1x,i4,' : ',2i10,:,' @ rank#',i0,':core#',i0)
1002  format(1x,5i10,1x,i4,' : ',2i10,  ' : TOTAL @ rank#', i0)
1003  format(1x,i6,' x',i2,4i10,1x,i4,' : ',2i10,' : TOTAL')
      DO TID=0, SELF%NUMOMP-1
         TLOC = SELF%TTHREAD(TID)
         ZFRAC = REAL(SELF%IGPC(TID),JPRB)/REAL(NGPTOT,JPRB)
         IF (TLOC > 0.0_JPRD) THEN
            ZMFLOPS = 1.0E-06_JPRB * ZFRAC * ZHPM * (REAL(NGPTOT,JPRB)/REAL(100,JPRB))/TLOC
         ELSE
            ZMFLOPS = 0.0_JPRB
         ENDIF
         ISENDBUF(1,TID) = SELF%COREID(TID)
         ISENDBUF(2,TID) = SELF%IGPC(TID)
         ISENDBUF(3,TID) = SELF%ICALLS(TID)
         ISENDBUF(4,TID) = INT(TLOC*1000.0_JPRB)
         ISENDBUF(5,TID) = INT(ZMFLOPS)
      ENDDO
      TDIFF = SELF%TEND - SELF%TSTART
      ZFRAC = 1.0_JPRB
      IF (TDIFF > 0.0_JPRB) THEN
         ZMFLOPS = 1.0E-06_JPRB * ZFRAC * ZHPM * (REAL(NGPTOT,JPRB)/REAL(100,JPRB))/TDIFF
      ELSE
         ZMFLOPS = 0.0_JPRB
      ENDIF
      ISENDBUF(1,SELF%NUMOMP) = NGPTOT
      ISENDBUF(2,SELF%NUMOMP) = SUM(SELF%IGPC)
      ISENDBUF(3,SELF%NUMOMP) = NGPBLKS
      ISENDBUF(4,SELF%NUMOMP) = INT(TDIFF*1000.0_JPRB)
      ISENDBUF(5,SELF%NUMOMP) = INT(ZMFLOPS)

      CALL CLOUDSC_MPI_GATHER_INT(ISENDBUF, 5 * (SELF%NUMOMP + 1), IRECVBUF, 5 * (SELF%NUMOMP+1), 0)

      IF (IRANK == 0) THEN
         WRITE(0,1000) 'NUMOMP','NGPTOT','#GP-cols','#BLKS','NPROMA','tid#','Time(msec)','MFlops/s'
         DO IPROC=0, NUMPROC-1
            DO TID=0, SELF%NUMOMP-1
               WRITE(0,1001) SELF%NUMOMP, IRECVBUF(1,SELF%NUMOMP,IPROC), IRECVBUF(2,TID,IPROC), &
                    & IRECVBUF(3,TID,IPROC), NPROMA, TID, IRECVBUF(4,TID,IPROC), IRECVBUF(5,TID,IPROC), &
                    & IPROC, IRECVBUF(1,TID,IPROC)
            ENDDO
            WRITE(0,1002) SELF%NUMOMP, IRECVBUF(1,SELF%NUMOMP,IPROC), IRECVBUF(2,SELF%NUMOMP,IPROC), &
                 & IRECVBUF(3,SELF%NUMOMP,IPROC), NPROMA, -1, IRECVBUF(4,SELF%NUMOMP,IPROC), &
                 & IRECVBUF(5,SELF%NUMOMP,IPROC), IPROC
         ENDDO
         WRITE(0,1003) NUMPROC, SELF%NUMOMP, SUM(IRECVBUF(1,SELF%NUMOMP,:)), &
                 & SUM(IRECVBUF(2,SELF%NUMOMP,:)), SUM(IRECVBUF(3,SELF%NUMOMP,:)), &
                 & NPROMA, -1, MAXVAL(IRECVBUF(4,SELF%NUMOMP,:)), SUM(IRECVBUF(5,SELF%NUMOMP,:))
      ENDIF

  END SUBROUTINE PERFORMANCE_TIMER_PRINT_PERFORMANCE

END MODULE TIMER_MOD
