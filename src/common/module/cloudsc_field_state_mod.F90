! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_FIELD_STATE_MOD
  ! Driver module to manage the setup and teardown of the field-based state
  USE PARKIND1,  ONLY : JPIM, JPRB, JPLM
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_MOD, ONLY: EXPAND, LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE, GET_OFFSETS
  USE VALIDATE_MOD, ONLY: VALIDATE
  USE CLOUDSC_MPI_MOD, ONLY: IRANK
  USE FIELD_MODULE, ONLY: FIELD_2RB, FIELD_3RB, FIELD_4RB, FIELD_2IM, FIELD_2LM, FIELD_3RB_PTR
  USE FIELD_FACTORY_MODULE, ONLY: FIELD_NEW, FIELD_DELETE

  IMPLICIT NONE

  TYPE CLOUDSC_FIELD_STATE
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX
    LOGICAL(KIND=JPLM)                   :: LDSLPHY
    LOGICAL(KIND=JPLM)                   :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    TYPE(STATE_TYPE) :: TENDENCY_LOC, TENDENCY_TMP

    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), ALLOCATABLE :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    CLASS(FIELD_4RB), POINTER :: DATA_RDONLY
    CLASS(FIELD_4RB), POINTER :: DATA_RWONLY

    ! Storage fields to provide thread-local views
    CLASS(FIELD_2RB), POINTER :: F_PRAINFRAC_TOPRFZ, F_PLSM
    CLASS(FIELD_2IM), POINTER :: F_KTYPE
    CLASS(FIELD_2LM), POINTER :: F_LDCUM
    CLASS(FIELD_3RB), POINTER :: F_PAPH, F_PCOVPTOT, F_PLUDE
    CLASS(FIELD_4RB), POINTER :: F_PCLV

    TYPE(FIELD_3RB_PTR), ALLOCATABLE :: FIELDS_RDONLY(:)
    TYPE(FIELD_3RB_PTR), ALLOCATABLE :: FIELDS_RWONLY(:)
  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_FIELD_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_FIELD_STATE_VALIDATE
    PROCEDURE :: FINALIZE => CLOUDSC_FIELD_STATE_FINALIZE
  END TYPE CLOUDSC_FIELD_STATE

  INTERFACE FIELD_INIT
    PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT


CONTAINS

  SUBROUTINE LOAD_AND_EXPAND_FIELD_2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2IM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    INTEGER(KIND=JPIM), ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2LM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL(KIND=JPLM), ALLOCATABLE :: BUFFER(:)
    LOGICAL(KIND=JPLM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_3D(NAME, FIELD, NLON, NLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_3RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_3D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_4D(NAME, FIELD, NLON, NLEV, NDIM, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_4RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV,NDIM,  NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, NDIM, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV, NDIM))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, NDIM, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NDIM, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_4D

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(STATE_TYPE), ALLOCATABLE, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), ALLOCATABLE, TARGET, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 3+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       STATE(B)%T => BUFFER(:,:,1,B)
       STATE(B)%A => BUFFER(:,:,2,B)
       STATE(B)%Q => BUFFER(:,:,3,B)
       STATE(B)%CLD => BUFFER(:,:,4:NFIELDS,B)
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_FIELD_STATE_LOAD(SELF, NPROMA, NGPTOT, NGPTOTG, USE_PACKED)
    USE FIELD_DEFAULTS_MODULE, ONLY: INIT_PINNED_VALUE, INIT_MAP_DEVPTR
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    ! Use this toggle to switch between standalone fields and bulk-allocated ones.
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED

    INTEGER(KIND=JPIM) :: KLON, NFIELDS
    INTEGER(KIND=JPIM) :: START, END, SIZE

    LOGICAL :: LLPACKED

    LLPACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) LLPACKED = USE_PACKED

    ! Set this flag to enable pinning of fields in page-locked memory
    INIT_PINNED_VALUE = .TRUE.
    ! Set this flag to disable host-mapped device pointers
    INIT_MAP_DEVPTR = .FALSE.

    CALL INPUT_INITIALIZE(NAME='input')

    SELF%NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    CALL GET_OFFSETS(START, END, SIZE, KLON, SELF%KLEV, NCLV, NGPTOT, NGPTOTG)

    IF (LLPACKED) THEN
      ! Allocate bulk buffers for read-only input 3D fields
      NFIELDS = 23
      CALL FIELD_NEW(SELF%DATA_RDONLY, SELF%FIELDS_RDONLY, UBOUNDS=[NPROMA, SELF%KLEV, NFIELDS, SELF%NBLOCKS], &
      &                          PERSISTENT=.TRUE.)

      ! This is a RDWR field, so does not belong in either of the buffers
      CALL FIELD_NEW(SELF%F_PLUDE, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)

      ! Custom fields that do not share shape or data type with the other blocks
      CALL FIELD_NEW(SELF%F_PAPH, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PLSM, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_LDCUM, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_KTYPE, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PCLV, UBOUNDS=[NPROMA,SELF%KLEV,NCLV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PCOVPTOT, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PRAINFRAC_TOPRFZ, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

      ! Allocate bulk buffers for output 3D fields
      NFIELDS = 14
      CALL FIELD_NEW(SELF%DATA_RWONLY, SELF%FIELDS_RWONLY, UBOUNDS=[NPROMA, SELF%KLEV+1, NFIELDS, SELF%NBLOCKS], &
      &                          PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

    ELSE
      ALLOCATE(SELF%FIELDS_RDONLY(23))
      ALLOCATE(SELF%FIELDS_RWONLY(14))

      CALL FIELD_NEW(SELF%FIELDS_RDONLY(1)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(2)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(3)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(4)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(5)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(6)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(7)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(8)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(9)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(10)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(11)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(12)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(13)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(14)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(15)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(16)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(17)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(18)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(19)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(20)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(21)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(22)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%FIELDS_RDONLY(23)%PTR, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)

      ! This is a RDWR field, so does not belong in either of the buffers
      CALL FIELD_NEW(SELF%F_PLUDE, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

      ! Custom fields that do not share shape or data type with the other blocks
      CALL FIELD_NEW(SELF%F_PAPH, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PLSM, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_LDCUM, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_KTYPE, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PCLV, UBOUNDS=[NPROMA,SELF%KLEV,NCLV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PCOVPTOT, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PRAINFRAC_TOPRFZ, UBOUNDS=[NPROMA,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

      ! Allocate bulk buffers for output 3D fields
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(1)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(2)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(3)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(4)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(5)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(6)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(7)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(8)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(9)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(10)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(11)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(12)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(13)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%FIELDS_RWONLY(14)%PTR, UBOUNDS=[NPROMA,SELF%KLEV+1,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

    END IF

    ! TODO: For now we treat all fields as single-allocations
    CALL FIELD_NEW(SELF%TENDENCY_LOC%F_T, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    CALL FIELD_NEW(SELF%TENDENCY_LOC%F_A, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    CALL FIELD_NEW(SELF%TENDENCY_LOC%F_Q, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    CALL FIELD_NEW(SELF%TENDENCY_LOC%F_CLD, UBOUNDS=[NPROMA,SELF%KLEV,NCLV,SELF%NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)

    CALL FIELD_NEW(SELF%TENDENCY_TMP%F_T, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%TENDENCY_TMP%F_A, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%TENDENCY_TMP%F_Q, UBOUNDS=[NPROMA,SELF%KLEV,SELF%NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%TENDENCY_TMP%F_CLD, UBOUNDS=[NPROMA,SELF%KLEV,NCLV,SELF%NBLOCKS], PERSISTENT=.TRUE.)

    CALL LOAD_AND_EXPAND_FIELD_3D('PLCRIT_AER', SELF%FIELDS_RDONLY(19)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PICRIT_AER', SELF%FIELDS_RDONLY(20)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PRE_ICE', SELF%FIELDS_RDONLY(21)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PCCN', SELF%FIELDS_RDONLY(22)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PNICE', SELF%FIELDS_RDONLY(23)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PT', SELF%FIELDS_RDONLY(1)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PQ', SELF%FIELDS_RDONLY(2)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFA', SELF%FIELDS_RDONLY(3)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFL', SELF%FIELDS_RDONLY(4)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFI', SELF%FIELDS_RDONLY(5)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNA', SELF%FIELDS_RDONLY(6)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNL', SELF%FIELDS_RDONLY(7)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNI', SELF%FIELDS_RDONLY(8)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRSW', SELF%FIELDS_RDONLY(9)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRLW', SELF%FIELDS_RDONLY(10)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVERVEL', SELF%FIELDS_RDONLY(11)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAP', SELF%FIELDS_RDONLY(12)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAPH', SELF%F_PAPH, KLON, SELF%KLEV+1, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_2D('PLSM', SELF%F_PLSM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_LOG2D('LDCUM', SELF%F_LDCUM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_INT2D('KTYPE', SELF%F_KTYPE, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLU', SELF%FIELDS_RDONLY(13)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLUDE', SELF%F_PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSNDE', SELF%FIELDS_RDONLY(14)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFU', SELF%FIELDS_RDONLY(15)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFD', SELF%FIELDS_RDONLY(16)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PA', SELF%FIELDS_RDONLY(17)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('PCLV', SELF%F_PCLV, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSUPSAT', SELF%FIELDS_RDONLY(18)%PTR, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_T', SELF%TENDENCY_TMP%F_T, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_A', SELF%TENDENCY_TMP%F_A, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_Q', SELF%TENDENCY_TMP%F_Q, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('TENDENCY_TMP_CLD', SELF%TENDENCY_TMP%F_CLD, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

  END SUBROUTINE CLOUDSC_FIELD_STATE_LOAD

  SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    INTEGER(KIND=JPIM) :: NBLOCKS, KLON, KLEV, KFLDX

    CALL INPUT_INITIALIZE(NAME='reference')

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', KLEV)
    CALL LOAD_SCALAR('KFLDX', KFLDX)

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF

    ! Load reference data and expand to our block layout
    CALL LOAD_AND_EXPAND('PLUDE', PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PCOVPTOT', PCOVPTOT, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLF', PFSQLF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQIF', PFSQIF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQLNG', PFCQLNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQNNG', PFCQNNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQRF', PFSQRF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQSF', PFSQSF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQRNG', PFCQRNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQSNG', PFCQSNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLTUR', PFSQLTUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQITUR', PFSQITUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSL', PFPLSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSN', PFPLSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSL', PFHPSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSN', PFHPSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_LOC', TENDENCY_LOC, B_LOC, KLON, SELF%KLEV, NCLV, &
         & NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL INPUT_FINALIZE()

    ! Actual variable validation
    CALL VALIDATE('PLUDE', PLUDE, SELF%F_PLUDE%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PCOVPTOT', PCOVPTOT, SELF%F_PCOVPTOT%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, SELF%F_PRAINFRAC_TOPRFZ%PTR, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLF', PFSQLF, SELF%FIELDS_RWONLY(1)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQIF', PFSQIF, SELF%FIELDS_RWONLY(2)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQLNG', PFCQLNG, SELF%FIELDS_RWONLY(3)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQNNG', PFCQNNG, SELF%FIELDS_RWONLY(4)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQRF', PFSQRF, SELF%FIELDS_RWONLY(5)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQSF', PFSQSF, SELF%FIELDS_RWONLY(6)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQRNG', PFCQRNG, SELF%FIELDS_RWONLY(7)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQSNG', PFCQSNG, SELF%FIELDS_RWONLY(8)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLTUR', PFSQLTUR, SELF%FIELDS_RWONLY(9)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQITUR', PFSQITUR, SELF%FIELDS_RWONLY(10)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSL', PFPLSL, SELF%FIELDS_RWONLY(11)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSN', PFPLSN, SELF%FIELDS_RWONLY(12)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSL', PFHPSL, SELF%FIELDS_RWONLY(13)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSN', PFHPSN, SELF%FIELDS_RWONLY(14)%PTR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)

    CALL VALIDATE('TENDENCY_LOC%A', B_LOC(:,:,2,:), SELF%TENDENCY_LOC%F_A%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%Q', B_LOC(:,:,3,:), SELF%TENDENCY_LOC%F_Q%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%T', B_LOC(:,:,1,:), SELF%TENDENCY_LOC%F_T%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%CLD', B_LOC(:,:,4:,:), SELF%TENDENCY_LOC%F_CLD%PTR, NPROMA, SELF%KLEV, NCLV, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE

  SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE(SELF, USE_PACKED)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    ! Use this toggle to switch between standalone fields and bulk-allocated ones.
    LOGICAL, INTENT(IN) :: USE_PACKED
    INTEGER :: IFIELD

    IF(USE_PACKED)THEN
      CALL FIELD_DELETE(SELF%DATA_RDONLY)
      CALL FIELD_DELETE(SELF%DATA_RWONLY)

      CALL FIELD_DELETE(SELF%F_PLUDE)
      CALL FIELD_DELETE(SELF%F_PAPH)
      CALL FIELD_DELETE(SELF%F_PLSM)
      CALL FIELD_DELETE(SELF%F_LDCUM)
      CALL FIELD_DELETE(SELF%F_KTYPE)
      CALL FIELD_DELETE(SELF%F_PCLV)
      CALL FIELD_DELETE(SELF%F_PCOVPTOT)
      CALL FIELD_DELETE(SELF%F_PRAINFRAC_TOPRFZ)
    ELSE
      DO IFIELD=1,23
         CALL FIELD_DELETE(SELF%FIELDS_RDONLY(IFIELD)%PTR)
      ENDDO

      CALL FIELD_DELETE(SELF%F_PLUDE)
      CALL FIELD_DELETE(SELF%F_PAPH)
      CALL FIELD_DELETE(SELF%F_PLSM)
      CALL FIELD_DELETE(SELF%F_LDCUM)
      CALL FIELD_DELETE(SELF%F_KTYPE)
      CALL FIELD_DELETE(SELF%F_PCLV)
      CALL FIELD_DELETE(SELF%F_PCOVPTOT)
      CALL FIELD_DELETE(SELF%F_PRAINFRAC_TOPRFZ)

      DO IFIELD=1,14
         CALL FIELD_DELETE(SELF%FIELDS_RWONLY(IFIELD)%PTR)
      ENDDO

      CALL FIELD_DELETE(SELF%TENDENCY_LOC%F_T)
      CALL FIELD_DELETE(SELF%TENDENCY_LOC%F_A)
      CALL FIELD_DELETE(SELF%TENDENCY_LOC%F_Q)
      CALL FIELD_DELETE(SELF%TENDENCY_LOC%F_CLD)

      CALL FIELD_DELETE(SELF%TENDENCY_TMP%F_T)
      CALL FIELD_DELETE(SELF%TENDENCY_TMP%F_A)
      CALL FIELD_DELETE(SELF%TENDENCY_TMP%F_Q)
      CALL FIELD_DELETE(SELF%TENDENCY_TMP%F_CLD)
    ENDIF

    DEALLOCATE(SELF%FIELDS_RDONLY)
    DEALLOCATE(SELF%FIELDS_RWONLY)

  END SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE

END MODULE CLOUDSC_FIELD_STATE_MOD
