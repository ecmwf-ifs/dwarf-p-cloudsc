! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_FIELD_STATE_MOD
  ! Driver module to manage the setup and teardown of the field-based state
  USE PARKIND1,  ONLY : JPIM, JPRB, JPLM
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_MOD, ONLY: EXPAND, LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE, GET_OFFSETS
  USE VALIDATE_MOD, ONLY: VALIDATE
  USE CLOUDSC_MPI_MOD, ONLY: IRANK
  USE FIELD_MODULE, ONLY: FIELD_2RB, FIELD_3RB, FIELD_4RB, FIELD_2IM, FIELD_2LM, FIELD_3RB_PTR
  USE FIELD_FACTORY_MODULE, ONLY: FIELD_NEW, FIELD_DELETE

  IMPLICIT NONE

  
    TYPE CLOUDSC_STATE_TYPE
      LOGICAL :: PACKED
      ! REAL(KIND=JPRB), DIMENSION(:,:), POINTER :: U,V,T   ! GMV FIELDS
      REAL(KIND=JPRB), DIMENSION(:,:), POINTER :: T   ! GMV FIELDS
      ! REAL(KIND=JPRB), DIMENSION(:,:), POINTER :: O3,Q,A  ! GFL FIELDS
      REAL(KIND=JPRB), DIMENSION(:,:), POINTER :: Q, A  ! GFL FIELDS
      REAL(KIND=JPRB), DIMENSION(:,:,:), POINTER :: CLD   ! COMPOSED CLOUD ARRAY
  
      CLASS(FIELD_3RB), POINTER :: F_T, F_A, F_Q
      CLASS(FIELD_4RB), POINTER :: F_CLD
      
      CLASS(FIELD_4RB), POINTER :: FIELD_GANG
      TYPE(FIELD_3RB_PTR), PRIVATE, ALLOCATABLE :: FIELD_PTRS(:)

    CONTAINS 
      PROCEDURE :: INIT => STATE_TYPE_INIT
      PROCEDURE :: UPDATE_VIEW => STATE_TYPE_UPDATE_VIEW
      PROCEDURE :: SYNC_HOST => STATE_TYPE_SYNC_HOST
      PROCEDURE :: FINAL => STATE_TYPE_FINAL
  END TYPE CLOUDSC_STATE_TYPE
  
  TYPE CLOUDSC_AUX_TYPE
  
    INTEGER(KIND=JPIM) :: NLEV
    LOGICAL :: PACKED
    ! 2D Fields
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLSM(:)       ! Land fraction (0-1)
    LOGICAL,         POINTER, CONTIGUOUS :: LDCUM(:)      ! Convection active
    INTEGER(KIND=JPIM), POINTER, CONTIGUOUS :: KTYPE(:)   ! Convection type 0,1,2
    ! 3D Fields   
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLCRIT_AER(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PICRIT_AER(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRE_ICE(:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCCN(:,:)     ! liquid cloud condensation nuclei
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PNICE(:,:)    ! ice number concentration (cf. CCN)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PT(:,:)       ! T at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PQ(:,:)       ! Q at start of callpar
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFA(:,:)     ! CC from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFL(:,:)     ! Liq from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVFI(:,:)     ! Ice from VDF scheme
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNA(:,:)    ! CC from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNL(:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PDYNI(:,:)    ! Liq from Dynamics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRSW(:,:)    ! Short-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PHRLW(:,:)    ! Long-wave heating rate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PVERVEL(:,:)  ! Vertical velocity
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAP(:,:)      ! Pressure on full levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PAPH(:,:)     ! Pressure on half levels
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLU(:,:)      ! Conv. condensate
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PLUDE(:,:)    ! Conv. detrained water
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSNDE(:,:)    ! Conv. detrained snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFU(:,:)     ! Conv. mass flux up
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PMFD(:,:)     ! Conv. mass flux down
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PA(:,:)       ! Original Cloud fraction (t)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PEXTRA(:,:,:) ! extra fields
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCLV(:,:,:)
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PSUPSAT(:,:)
    ! Output fields used for validation
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PCOVPTOT(:,:) ! Precip fraction
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PRAINFRAC_TOPRFZ(:)
    
    ! field gang for 3D fields
    CLASS(FIELD_4RB), POINTER :: DATA_RDONLY
    ! Acces pointers for 3D fields in gang
    TYPE(FIELD_3RB_PTR), ALLOCATABLE :: FIELDS_RDONLY(:)
  
    CLASS(FIELD_2IM), POINTER :: F_KTYPE
    CLASS(FIELD_2LM), POINTER :: F_LDCUM
    CLASS(FIELD_2RB), POINTER :: F_PLSM, F_PRAINFRAC_TOPRFZ
    CLASS(FIELD_3RB), POINTER :: F_PLCRIT_AER, F_PICRIT_AER, F_PRE_ICE, F_PCCN, &
        F_PNICE, F_PT, F_PQ, F_PVFA, F_PVFL, F_PVFI, F_PDYNA, F_PDYNL, F_PDYNI, &
        F_PHRSW, F_PHRLW, F_PVERVEL, F_PAP, F_PAPH, F_PLU, F_PLUDE, F_PSNDE,    &
        F_PMFU, F_PMFD, F_PA, F_PSUPSAT, F_PCOVPTOT
    CLASS(FIELD_4RB), POINTER :: F_PEXTRA, F_PCLV
  
  CONTAINS
    PROCEDURE :: INIT => AUX_TYPE_INIT
    PROCEDURE :: UPDATE_VIEW => AUX_TYPE_UPDATE_VIEW
    PROCEDURE :: SYNC_HOST => AUX_TYPE_SYNC_HOST
    PROCEDURE :: FINAL => AUX_TYPE_FINAL
  
  END TYPE CLOUDSC_AUX_TYPE

  TYPE CLOUDSC_FLUX_TYPE
  
    INTEGER(KIND=JPIM) :: NLEV
    LOGICAL :: PACKED
    
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLF(:,:)   ! Flux of liquid
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQIF(:,:)   ! Flux of ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQLNG(:,:)  ! -ve corr for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQNNG(:,:)  ! -ve corr for ice
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQRF(:,:)   ! Flux diagnostics
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQSF(:,:)   ! for DDH, generic
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQRNG(:,:)  ! rain
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFCQSNG(:,:)  ! snow
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQLTUR(:,:) ! liquid flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFSQITUR(:,:) ! ice flux due to VDF
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSL(:,:)   ! liq+rain sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFPLSN(:,:)   ! ice+snow sedim flux
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSL(:,:)   ! Enthalpy flux for liq
    REAL(KIND=JPRB), POINTER, CONTIGUOUS :: PFHPSN(:,:)   ! Enthalp flux for ice
    
    CLASS(FIELD_3RB), POINTER :: F_PFSQLF, F_PFSQIF, F_PFCQLNG, F_PFCQNNG, F_PFSQRF, F_PFSQSF, &
      & F_PFCQRNG, F_PFCQSNG, F_PFSQLTUR, F_PFSQITUR, F_PFPLSL, F_PFPLSN, F_PFHPSL, F_PFHPSN
  
    CLASS(FIELD_4RB), POINTER :: DATA_WRONLY ! ACTUAL FIELD storing data
    TYPE(FIELD_3RB_PTR), ALLOCATABLE :: FIELDS_WRONLY(:) ! Array of field pointers
  
  CONTAINS
    PROCEDURE :: INIT => FLUX_TYPE_INIT
    PROCEDURE :: UPDATE_VIEW => FLUX_TYPE_UPDATE_VIEW
    PROCEDURE :: SYNC_HOST => FLUX_TYPE_SYNC_HOST
    PROCEDURE :: FINAL => FLUX_TYPE_FINAL
  
  END TYPE CLOUDSC_FLUX_TYPE

  TYPE CLOUDSC_FIELD_STATE
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX
    LOGICAL(KIND=JPLM)                   :: LDSLPHY
    LOGICAL(KIND=JPLM)                   :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    TYPE(CLOUDSC_STATE_TYPE) :: TENDENCY_LOC, TENDENCY_TMP
    TYPE(CLOUDSC_AUX_TYPE) :: AUX
    TYPE(CLOUDSC_FLUX_TYPE) :: FLUX
    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), ALLOCATABLE :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)


  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_FIELD_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_FIELD_STATE_VALIDATE
    PROCEDURE :: FINALIZE => CLOUDSC_FIELD_STATE_FINALIZE
  END TYPE CLOUDSC_FIELD_STATE

  INTERFACE FIELD_INIT
    PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT


CONTAINS

  SUBROUTINE LOAD_AND_EXPAND_FIELD_2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2IM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    INTEGER(KIND=JPIM), ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2LM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL(KIND=JPLM), ALLOCATABLE :: BUFFER(:)
    LOGICAL(KIND=JPLM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_3D(NAME, FIELD, NLON, NLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_3RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_3D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_4D(NAME, FIELD, NLON, NLEV, NDIM, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_4RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV,NDIM,  NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, NDIM, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV, NDIM))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, NDIM, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NDIM, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_4D

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(CLOUDSC_STATE_TYPE), ALLOCATABLE, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), ALLOCATABLE, TARGET, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 3+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       STATE(B)%T => BUFFER(:,:,1,B)
       STATE(B)%A => BUFFER(:,:,2,B)
       STATE(B)%Q => BUFFER(:,:,3,B)
       STATE(B)%CLD => BUFFER(:,:,4:NFIELDS,B)
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_FIELD_STATE_LOAD(SELF, NPROMA, NGPTOT, NGPTOTG, USE_PACKED)
    USE FIELD_DEFAULTS_MODULE, ONLY: INIT_PINNED_VALUE, INIT_MAP_DEVPTR
    ! Load reference input data via serialbox
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    ! Use this toggle to switch between standalone fields and bulk-allocated ones.
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED

    INTEGER(KIND=JPIM) :: KLON, NFIELDS
    INTEGER(KIND=JPIM) :: START, END, SIZE

    LOGICAL :: LLPACKED

    LLPACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) LLPACKED = USE_PACKED

    ! Set this flag to enable pinning of fields in page-locked memory
    ! INIT_PINNED_VALUE = .TRUE.
    ! Set this flag to disable host-mapped device pointers
    INIT_MAP_DEVPTR = .FALSE.

    CALL INPUT_INITIALIZE(NAME='input')

    SELF%NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)

    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    ! Note, why is this call here?
    CALL GET_OFFSETS(START, END, SIZE, KLON, SELF%KLEV, NCLV, NGPTOT, NGPTOTG)

    CALL SELF%AUX%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    CALL SELF%FLUX%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    ! TENDENCIES
    CALL SELF%TENDENCY_LOC%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    CALL SELF%TENDENCY_TMP%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

  END SUBROUTINE CLOUDSC_FIELD_STATE_LOAD

  SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    INTEGER(KIND=JPIM) :: NBLOCKS, KLON, KLEV, KFLDX

    CALL INPUT_INITIALIZE(NAME='reference')

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', KLEV)
    CALL LOAD_SCALAR('KFLDX', KFLDX)

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF

    ! Load reference data and expand to our block layout
    CALL LOAD_AND_EXPAND('PLUDE', PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PCOVPTOT', PCOVPTOT, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLF', PFSQLF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQIF', PFSQIF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQLNG', PFCQLNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQNNG', PFCQNNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQRF', PFSQRF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQSF', PFSQSF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQRNG', PFCQRNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQSNG', PFCQSNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLTUR', PFSQLTUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQITUR', PFSQITUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSL', PFPLSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSN', PFPLSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSL', PFHPSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSN', PFHPSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_LOC', TENDENCY_LOC, B_LOC, KLON, SELF%KLEV, NCLV, &
         & NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL INPUT_FINALIZE()

    ! Actual variable validation
    CALL VALIDATE('PLUDE', PLUDE, SELF%AUX%F_PLUDE%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PCOVPTOT', PCOVPTOT, SELF%AUX%F_PCOVPTOT%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, SELF%AUX%F_PRAINFRAC_TOPRFZ%PTR, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLF', PFSQLF, SELF%FLUX%F_PFSQLF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQIF', PFSQIF, SELF%FLUX%F_PFSQIF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQLNG', PFCQLNG, SELF%FLUX%F_PFCQLNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQNNG', PFCQNNG, SELF%FLUX%F_PFCQNNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQRF', PFSQRF, SELF%FLUX%F_PFSQRF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQSF', PFSQSF, SELF%FLUX%F_PFSQSF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQRNG', PFCQRNG, SELF%FLUX%F_PFCQRNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQSNG', PFCQSNG, SELF%FLUX%F_PFCQSNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLTUR', PFSQLTUR, SELF%FLUX%F_PFSQLTUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQITUR', PFSQITUR, SELF%FLUX%F_PFSQITUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSL', PFPLSL, SELF%FLUX%F_PFPLSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSN', PFPLSN, SELF%FLUX%F_PFPLSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSL', PFHPSL, SELF%FLUX%F_PFHPSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSN', PFHPSN, SELF%FLUX%F_PFHPSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)

    CALL VALIDATE('TENDENCY_LOC%A', B_LOC(:,:,2,:), SELF%TENDENCY_LOC%F_A%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%Q', B_LOC(:,:,3,:), SELF%TENDENCY_LOC%F_Q%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%T', B_LOC(:,:,1,:), SELF%TENDENCY_LOC%F_T%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%CLD', B_LOC(:,:,4:,:), SELF%TENDENCY_LOC%F_CLD%PTR, NPROMA, SELF%KLEV, NCLV, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE

  
  SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE(SELF)
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    CALL SELF%AUX%FINAL()
    CALL SELF%FLUX%FINAL()
    CALL SELF%TENDENCY_LOC%FINAL()
    CALL SELF%TENDENCY_TMP%FINAL()
  END SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE


  SUBROUTINE STATE_TYPE_INIT(SELF,NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS, NGPTOTG, USE_PACKED)
    CLASS(CLOUDSC_STATE_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS 
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED
    
    INTEGER(KIND=JPIM), PARAMETER :: NPACKED_FIELDS = 3

    SELF%PACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) SELF%PACKED = USE_PACKED
     
    IF (SELF%PACKED) THEN
      CALL FIELD_NEW(SELF%FIELD_GANG, SELF%FIELD_PTRS, UBOUNDS=[NPROMA,KLEV,NPACKED_FIELDS,NBLOCKS], &
        & PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
        SELF%F_T => SELF%FIELD_PTRS(1)%PTR
        SELF%F_A => SELF%FIELD_PTRS(2)%PTR
        SELF%F_Q => SELF%FIELD_PTRS(3)%PTR
    ELSE
      CALL FIELD_NEW(SELF%F_T, UBOUNDS=[NPROMA,KLEV,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_A, UBOUNDS=[NPROMA,KLEV,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_Q, UBOUNDS=[NPROMA,KLEV,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    END IF
    CALL FIELD_NEW(SELF%F_CLD, UBOUNDS=[NPROMA,KLEV,NCLV,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    
    ! TODO This really shouldn't load this for both TMP and Local Tendency objects, perhaps make a LOAD method
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_T', SELF%F_T, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_A', SELF%F_A, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_Q', SELF%F_Q, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('TENDENCY_TMP_CLD', SELF%F_CLD, KLON, KLEV, NCLV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE STATE_TYPE_INIT
  
  
  SUBROUTINE STATE_TYPE_UPDATE_VIEW(SELF, BLOCK_INDEX)
    CLASS(CLOUDSC_STATE_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    
    IF(ASSOCIATED(SELF%F_T)) SELF%T => SELF%F_T%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_Q)) SELF%Q => SELF%F_Q%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_A)) SELF%A => SELF%F_A%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_CLD)) SELF%CLD => SELF%F_CLD%GET_VIEW(BLOCK_INDEX)
     
  END SUBROUTINE STATE_TYPE_UPDATE_VIEW


  SUBROUTINE STATE_TYPE_SYNC_HOST(SELF)
    CLASS(CLOUDSC_STATE_TYPE) :: SELF
    CALL SELF%F_T%SYNC_HOST_RDWR()
    CALL SELF%F_Q%SYNC_HOST_RDWR()
    CALL SELF%F_A%SYNC_HOST_RDWR()
    CALL SELF%F_CLD%SYNC_HOST_RDWR()
    ! Note , this deletion is done in the IFS, I am not sure, whether we wan't to do this in the cloudsc kernel
    IF (ASSOCIATED(SELF%F_T))   CALL SELF%F_T%DELETE_DEVICE_DATA()
    IF (ASSOCIATED(SELF%F_Q))   CALL SELF%F_Q%DELETE_DEVICE_DATA()
    IF (ASSOCIATED(SELF%F_A))   CALL SELF%F_A%DELETE_DEVICE_DATA()
    IF (ASSOCIATED(SELF%F_CLD)) CALL SELF%F_CLD%DELETE_DEVICE_DATA()
  END SUBROUTINE STATE_TYPE_SYNC_HOST
  
  SUBROUTINE STATE_TYPE_FINAL(SELF)
    CLASS(CLOUDSC_STATE_TYPE) :: SELF
    IF (SELF%PACKED) THEN
     CALL FIELD_DELETE(SELF%FIELD_GANG)
     DEALLOCATE(SELF%FIELD_GANG)
    ELSE
      CALL FIELD_DELETE(SELF%F_T)
      CALL FIELD_DELETE(SELF%F_Q)
      CALL FIELD_DELETE(SELF%F_A)
    END IF
    CALL FIELD_DELETE(SELF%F_CLD)
  END SUBROUTINE STATE_TYPE_FINAL


  SUBROUTINE AUX_TYPE_INIT(SELF,NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS, NGPTOTG, USE_PACKED)
    CLASS(CLOUDSC_AUX_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS 
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED
    
    INTEGER(KIND=JPIM), PARAMETER :: NFIELDS = 23

    SELF%PACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) SELF%PACKED = USE_PACKED


    
    ! 2D Fields  
    CALL FIELD_NEW(SELF%F_PLSM, UBOUNDS=[NPROMA,NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%F_LDCUM, UBOUNDS=[NPROMA,NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%F_KTYPE, UBOUNDS=[NPROMA,NBLOCKS], PERSISTENT=.TRUE.)
    ! 3D special fields
    CALL FIELD_NEW(SELF%F_PLUDE, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.) ! RDWR field
    CALL FIELD_NEW(SELF%F_PAPH, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE.)
    ! 4D Fields 
    CALL FIELD_NEW(SELF%F_PEXTRA, UBOUNDS=[NPROMA,KLEV,NCLV,NBLOCKS], PERSISTENT=.TRUE.)
    CALL FIELD_NEW(SELF%F_PCLV, UBOUNDS=[NPROMA,KLEV,NCLV,NBLOCKS], PERSISTENT=.TRUE.)
    ! Validation Fields 
    CALL FIELD_NEW(SELF%F_PCOVPTOT, UBOUNDS=[NPROMA,KLEV,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    CALL FIELD_NEW(SELF%F_PRAINFRAC_TOPRFZ, UBOUNDS=[NPROMA,NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    
    ! 3D rdonly fields
    IF (SELF%PACKED) THEN
      CALL FIELD_NEW(SELF%DATA_RDONLY, SELF%FIELDS_RDONLY, UBOUNDS=[NPROMA, KLEV, NFIELDS, NBLOCKS], &
      &                          PERSISTENT=.TRUE.)
      SELF%F_PLCRIT_AER   =>  SELF%FIELDS_RDONLY(1)%PTR
      SELF%F_PICRIT_AER   =>  SELF%FIELDS_RDONLY(2)%PTR
      SELF%F_PRE_ICE      =>  SELF%FIELDS_RDONLY(3)%PTR
      SELF%F_PCCN         =>  SELF%FIELDS_RDONLY(4)%PTR
      SELF%F_PNICE        =>  SELF%FIELDS_RDONLY(5)%PTR
      SELF%F_PT           =>  SELF%FIELDS_RDONLY(6)%PTR
      SELF%F_PQ           =>  SELF%FIELDS_RDONLY(7)%PTR
      SELF%F_PVFA         =>  SELF%FIELDS_RDONLY(8)%PTR
      SELF%F_PVFL         =>  SELF%FIELDS_RDONLY(9)%PTR
      SELF%F_PVFI         =>  SELF%FIELDS_RDONLY(10)%PTR
      SELF%F_PDYNA        =>  SELF%FIELDS_RDONLY(11)%PTR
      SELF%F_PDYNL        =>  SELF%FIELDS_RDONLY(12)%PTR
      SELF%F_PDYNI        =>  SELF%FIELDS_RDONLY(13)%PTR
      SELF%F_PHRSW        =>  SELF%FIELDS_RDONLY(14)%PTR
      SELF%F_PHRLW        =>  SELF%FIELDS_RDONLY(15)%PTR
      SELF%F_PVERVEL      =>  SELF%FIELDS_RDONLY(16)%PTR
      SELF%F_PAP          =>  SELF%FIELDS_RDONLY(17)%PTR
      SELF%F_PLU          =>  SELF%FIELDS_RDONLY(18)%PTR
      SELF%F_PSNDE        =>  SELF%FIELDS_RDONLY(19)%PTR
      SELF%F_PMFU         =>  SELF%FIELDS_RDONLY(20)%PTR
      SELF%F_PMFD         =>  SELF%FIELDS_RDONLY(21)%PTR
      SELF%F_PA           =>  SELF%FIELDS_RDONLY(22)%PTR
      SELF%F_PSUPSAT      =>  SELF%FIELDS_RDONLY(23)%PTR
    ELSE
      CALL FIELD_NEW(SELF%F_PLCRIT_AER, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PICRIT_AER, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PRE_ICE, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PCCN, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PNICE, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PT, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PQ, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PVFA, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PVFL, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PVFI, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PDYNA, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PDYNL, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PDYNI, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PHRSW, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PHRLW, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PVERVEL, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PAP, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PLU, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PSNDE, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PMFU, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PMFD, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PA, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
      CALL FIELD_NEW(SELF%F_PSUPSAT, UBOUNDS=[NPROMA, KLEV, NBLOCKS], PERSISTENT=.TRUE.)
    END IF


    ! LOAD input data
    ! 2D Fields  
    CALL LOAD_AND_EXPAND_FIELD_2D('PLSM', SELF%F_PLSM, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_LOG2D('LDCUM', SELF%F_LDCUM, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_INT2D('KTYPE', SELF%F_KTYPE, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ! 3D fields
    CALL LOAD_AND_EXPAND_FIELD_3D('PLCRIT_AER', SELF%F_PLCRIT_AER, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PICRIT_AER', SELF%F_PICRIT_AER, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PRE_ICE', SELF%F_PRE_ICE, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PCCN', SELF%F_PCCN, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PNICE', SELF%F_PNICE, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PT', SELF%F_PT, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PQ', SELF%F_PQ, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFA', SELF%F_PVFA, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFL', SELF%F_PVFL, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFI', SELF%F_PVFI, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNA', SELF%F_PDYNA, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNL', SELF%F_PDYNL, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNI', SELF%F_PDYNI, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRSW', SELF%F_PHRSW, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRLW', SELF%F_PHRLW, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVERVEL', SELF%F_PVERVEL, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAP', SELF%F_PAP, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAPH', SELF%F_PAPH, KLON, KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLU', SELF%F_PLU, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLUDE', SELF%F_PLUDE, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSNDE', SELF%F_PSNDE, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFU', SELF%F_PMFU, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFD', SELF%F_PMFD, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PA', SELF%F_PA, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSUPSAT', SELF%F_PSUPSAT, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ! 4D fields
    ! CALL FIELD_NEW('PEXTRA', SELF%F_PEXTRA, KLON, KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('PCLV', SELF%F_PCLV, KLON, KLEV, NCLV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    ! output fields
    ! THEY DO NOT HAVE TO BE LOADED FIXME: MAYBE THEY HAVE TO!??!?!?
  END SUBROUTINE AUX_TYPE_INIT

  SUBROUTINE AUX_TYPE_UPDATE_VIEW(SELF, BLOCK_INDEX)
    CLASS(CLOUDSC_AUX_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    
    ! 2D fields
    IF(ASSOCIATED(SELF%F_PLSM)) SELF%PLSM => SELF%F_PLSM%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_LDCUM)) SELF%LDCUM => SELF%F_LDCUM%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_KTYPE)) SELF%KTYPE => SELF%F_KTYPE%GET_VIEW(BLOCK_INDEX)
    ! 3D Fields
    IF(ASSOCIATED(SELF%F_PLCRIT_AER)) SELF%PLCRIT_AER => SELF%F_PLCRIT_AER%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PICRIT_AER)) SELF%PICRIT_AER => SELF%F_PICRIT_AER%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PRE_ICE)) SELF%PRE_ICE => SELF%F_PRE_ICE%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PCCN)) SELF%PCCN => SELF%F_PCCN%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PNICE)) SELF%PNICE => SELF%F_PNICE%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PT)) SELF%PT => SELF%F_PT%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PQ)) SELF%PQ => SELF%F_PQ%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PVFA)) SELF%PVFA => SELF%F_PVFA%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PVFL)) SELF%PVFL => SELF%F_PVFL%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PVFI)) SELF%PVFI => SELF%F_PVFI%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PDYNA)) SELF%PDYNA => SELF%F_PDYNA%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PDYNL)) SELF%PDYNL => SELF%F_PDYNL%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PDYNI)) SELF%PDYNI => SELF%F_PDYNI%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PHRSW)) SELF%PHRSW => SELF%F_PHRSW%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PHRLW)) SELF%PHRLW => SELF%F_PHRLW%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PVERVEL)) SELF%PVERVEL => SELF%F_PVERVEL%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PAP)) SELF%PAP => SELF%F_PAP%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PAPH)) SELF%PAPH => SELF%F_PAPH%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PLU)) SELF%PLU => SELF%F_PLU%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PLUDE)) SELF%PLUDE => SELF%F_PLUDE%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PSNDE)) SELF%PSNDE => SELF%F_PSNDE%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PMFU)) SELF%PMFU => SELF%F_PMFU%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PMFD)) SELF%PMFD => SELF%F_PMFD%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PA)) SELF%PA => SELF%F_PA%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PSUPSAT)) SELF%PSUPSAT => SELF%F_PSUPSAT%GET_VIEW(BLOCK_INDEX)
    ! 4D fields 
    IF(ASSOCIATED(SELF%F_PEXTRA)) SELF%PEXTRA => SELF%F_PEXTRA%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PCLV)) SELF%PCLV => SELF%F_PCLV%GET_VIEW(BLOCK_INDEX)
    ! validation Fields 
    IF(ASSOCIATED(SELF%F_PCOVPTOT)) SELF%PCOVPTOT => SELF%F_PCOVPTOT%GET_VIEW(BLOCK_INDEX)
    IF(ASSOCIATED(SELF%F_PRAINFRAC_TOPRFZ)) SELF%PRAINFRAC_TOPRFZ => SELF%F_PRAINFRAC_TOPRFZ%GET_VIEW(BLOCK_INDEX)

  END SUBROUTINE AUX_TYPE_UPDATE_VIEW

  SUBROUTINE AUX_TYPE_SYNC_HOST(SELF)
    CLASS(CLOUDSC_AUX_TYPE) :: SELF
    ! Validation Fields 
    CALL SELF%F_PLUDE%SYNC_HOST_RDWR()
    CALL SELF%F_PCOVPTOT%SYNC_HOST_RDWR()
    CALL SELF%F_PRAINFRAC_TOPRFZ%SYNC_HOST_RDWR()
  END SUBROUTINE AUX_TYPE_SYNC_HOST

  SUBROUTINE AUX_TYPE_FINAL(SELF)
    CLASS(CLOUDSC_AUX_TYPE) :: SELF
    ! 2D Fields  
    CALL FIELD_DELETE(SELF%F_PLSM)
    CALL FIELD_DELETE(SELF%F_LDCUM)
    CALL FIELD_DELETE(SELF%F_KTYPE)
    ! 3D special fields
    CALL FIELD_DELETE(SELF%F_PLUDE)
    CALL FIELD_DELETE(SELF%F_PAPH)
    ! 4D Fields 
    CALL FIELD_DELETE(SELF%F_PEXTRA)
    CALL FIELD_DELETE(SELF%F_PCLV)
    ! Validation fields 
    CALL FIELD_DELETE(SELF%F_PCOVPTOT)
    CALL FIELD_DELETE(SELF%F_PRAINFRAC_TOPRFZ)
    ! 3D wronly fields
    IF(SELF%PACKED) THEN
      CALL FIELD_DELETE(SELF%DATA_RDONLY)
      DEALLOCATE(SELF%FIELDS_RDONLY)
    ELSE
      CALL FIELD_DELETE(SELF%F_PLCRIT_AER)
      CALL FIELD_DELETE(SELF%F_PICRIT_AER)
      CALL FIELD_DELETE(SELF%F_PRE_ICE)
      CALL FIELD_DELETE(SELF%F_PCCN)
      CALL FIELD_DELETE(SELF%F_PNICE)
      CALL FIELD_DELETE(SELF%F_PT)
      CALL FIELD_DELETE(SELF%F_PQ)
      CALL FIELD_DELETE(SELF%F_PVFA)
      CALL FIELD_DELETE(SELF%F_PVFL)
      CALL FIELD_DELETE(SELF%F_PVFI)
      CALL FIELD_DELETE(SELF%F_PDYNA)
      CALL FIELD_DELETE(SELF%F_PDYNL)
      CALL FIELD_DELETE(SELF%F_PDYNI)
      CALL FIELD_DELETE(SELF%F_PHRSW)
      CALL FIELD_DELETE(SELF%F_PHRLW)
      CALL FIELD_DELETE(SELF%F_PVERVEL)
      CALL FIELD_DELETE(SELF%F_PAP)
      CALL FIELD_DELETE(SELF%F_PLU)
      CALL FIELD_DELETE(SELF%F_PSNDE)
      CALL FIELD_DELETE(SELF%F_PMFU)
      CALL FIELD_DELETE(SELF%F_PMFD)
      CALL FIELD_DELETE(SELF%F_PA)
      CALL FIELD_DELETE(SELF%F_PSUPSAT)
    END IF
  END SUBROUTINE AUX_TYPE_FINAL

  SUBROUTINE FLUX_TYPE_INIT(SELF,NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS, NGPTOTG, USE_PACKED)
    CLASS(CLOUDSC_FLUX_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT, KLON, KLEV, KFLDX, NBLOCKS 
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED
    
    INTEGER(KIND=JPIM), PARAMETER :: NFIELDS = 14

    SELF%PACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) SELF%PACKED = USE_PACKED
  
    
    IF (SELF%PACKED) THEN
      CALL FIELD_NEW(SELF%DATA_WRONLY, SELF%FIELDS_WRONLY, UBOUNDS=[NPROMA, KLEV+1, NFIELDS, NBLOCKS], &
      &                          PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      SELF%F_PFSQLF   => SELF%FIELDS_WRONLY(1)%PTR
      SELF%F_PFSQIF   => SELF%FIELDS_WRONLY(2)%PTR
      SELF%F_PFCQLNG  => SELF%FIELDS_WRONLY(3)%PTR
      SELF%F_PFCQNNG  => SELF%FIELDS_WRONLY(4)%PTR
      SELF%F_PFSQRF   => SELF%FIELDS_WRONLY(5)%PTR
      SELF%F_PFSQSF   => SELF%FIELDS_WRONLY(6)%PTR
      SELF%F_PFCQRNG  => SELF%FIELDS_WRONLY(7)%PTR
      SELF%F_PFCQSNG  => SELF%FIELDS_WRONLY(8)%PTR
      SELF%F_PFSQLTUR => SELF%FIELDS_WRONLY(9)%PTR
      SELF%F_PFSQITUR => SELF%FIELDS_WRONLY(10)%PTR
      SELF%F_PFPLSL   => SELF%FIELDS_WRONLY(11)%PTR
      SELF%F_PFPLSN   => SELF%FIELDS_WRONLY(12)%PTR
      SELF%F_PFHPSL   => SELF%FIELDS_WRONLY(13)%PTR
      SELF%F_PFHPSN   => SELF%FIELDS_WRONLY(14)%PTR
    ELSE
      CALL FIELD_NEW(SELF%F_PFSQLF, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFSQIF, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFCQLNG, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFCQNNG, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFSQRF, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFSQSF, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFCQRNG, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFCQSNG, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFSQLTUR, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFSQITUR, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFPLSL, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFPLSN, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFHPSL, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
      CALL FIELD_NEW(SELF%F_PFHPSN, UBOUNDS=[NPROMA, KLEV+1, NBLOCKS], PERSISTENT=.TRUE., INIT_VALUE=0._JPRB)
    END IF

  END SUBROUTINE FLUX_TYPE_INIT

  SUBROUTINE FLUX_TYPE_UPDATE_VIEW(SELF, BLOCK_INDEX)
    CLASS(CLOUDSC_FLUX_TYPE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: BLOCK_INDEX
    
   IF(ASSOCIATED(SELF%F_PFSQLF))    SELF%PFSQLF   => SELF%F_PFSQLF%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFSQIF))    SELF%PFSQIF   => SELF%F_PFSQIF%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFCQLNG))   SELF%PFCQLNG  => SELF%F_PFCQLNG%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFCQNNG))   SELF%PFCQNNG  => SELF%F_PFCQNNG%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFSQRF))    SELF%PFSQRF   => SELF%F_PFSQRF%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFSQSF))    SELF%PFSQSF   => SELF%F_PFSQSF%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFCQRNG))   SELF%PFCQRNG  => SELF%F_PFCQRNG%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFCQSNG))   SELF%PFCQSNG  => SELF%F_PFCQSNG%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFSQLTUR))  SELF%PFSQLTUR => SELF%F_PFSQLTUR%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFSQITUR))  SELF%PFSQITUR => SELF%F_PFSQITUR%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFPLSL))    SELF%PFPLSL   => SELF%F_PFPLSL%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFPLSN))    SELF%PFPLSN   => SELF%F_PFPLSN%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFHPSL))    SELF%PFHPSL   => SELF%F_PFHPSL%GET_VIEW(BLOCK_INDEX)
   IF(ASSOCIATED(SELF%F_PFHPSN))    SELF%PFHPSN   => SELF%F_PFHPSN%GET_VIEW(BLOCK_INDEX)

  END SUBROUTINE FLUX_TYPE_UPDATE_VIEW

  SUBROUTINE FLUX_TYPE_SYNC_HOST(SELF)
    CLASS(CLOUDSC_FLUX_TYPE) :: SELF
    
    IF (SELF%PACKED) THEN
      CALL SELF%DATA_WRONLY%SYNC_HOST_RDWR()
    ELSE 
      CALL SELF%F_PFSQLF%SYNC_HOST_RDWR()
      CALL SELF%F_PFSQIF%SYNC_HOST_RDWR()
      CALL SELF%F_PFCQLNG%SYNC_HOST_RDWR()
      CALL SELF%F_PFCQNNG%SYNC_HOST_RDWR()
      CALL SELF%F_PFSQRF%SYNC_HOST_RDWR()
      CALL SELF%F_PFSQSF%SYNC_HOST_RDWR()
      CALL SELF%F_PFCQRNG%SYNC_HOST_RDWR()
      CALL SELF%F_PFCQSNG%SYNC_HOST_RDWR()
      CALL SELF%F_PFSQLTUR%SYNC_HOST_RDWR()
      CALL SELF%F_PFSQITUR%SYNC_HOST_RDWR()
      CALL SELF%F_PFPLSL%SYNC_HOST_RDWR()
      CALL SELF%F_PFPLSN%SYNC_HOST_RDWR()
      CALL SELF%F_PFHPSL%SYNC_HOST_RDWR()
      CALL SELF%F_PFHPSN%SYNC_HOST_RDWR()
    ENDIF
  END SUBROUTINE FLUX_TYPE_SYNC_HOST

  SUBROUTINE FLUX_TYPE_FINAL(SELF)
    CLASS(CLOUDSC_FLUX_TYPE) :: SELF
    
    IF (SELF%PACKED) THEN
      CALL FIELD_DELETE(SELF%DATA_WRONLY)
      DEALLOCATE(SELF%FIELDS_WRONLY)
    ELSE
      CALL FIELD_DELETE(SELF%F_PFSQLF)
      CALL FIELD_DELETE(SELF%F_PFSQIF)
      CALL FIELD_DELETE(SELF%F_PFCQLNG)
      CALL FIELD_DELETE(SELF%F_PFCQNNG)
      CALL FIELD_DELETE(SELF%F_PFSQRF)
      CALL FIELD_DELETE(SELF%F_PFSQSF)
      CALL FIELD_DELETE(SELF%F_PFCQRNG)
      CALL FIELD_DELETE(SELF%F_PFCQSNG)
      CALL FIELD_DELETE(SELF%F_PFSQLTUR)
      CALL FIELD_DELETE(SELF%F_PFSQITUR)
      CALL FIELD_DELETE(SELF%F_PFPLSL)
      CALL FIELD_DELETE(SELF%F_PFPLSN)
      CALL FIELD_DELETE(SELF%F_PFHPSL)
      CALL FIELD_DELETE(SELF%F_PFHPSN)
    ENDIF
  END SUBROUTINE FLUX_TYPE_FINAL

END MODULE CLOUDSC_FIELD_STATE_MOD
