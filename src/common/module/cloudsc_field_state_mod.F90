! (C) Copyright 1988- ECMWF.
!
! This software is licensed under the terms of the Apache Licence Version 2.0
! which can be obtained at http://www.apache.org/licenses/LICENSE-2.0.
!
! In applying this licence, ECMWF does not waive the privileges and immunities
! granted to it by virtue of its status as an intergovernmental organisation
! nor does it submit to any jurisdiction.

MODULE CLOUDSC_FIELD_STATE_MOD
  ! Driver module to manage the setup and teardown of the field-based state
  USE PARKIND1,  ONLY : JPIM, JPRB, JPLM
  USE YOMPHYDER, ONLY : STATE_TYPE
  USE YOECLDP,   ONLY : NCLV, YRECLDP, YRECLDP_LOAD_PARAMETERS
  USE YOMCST,    ONLY : YOMCST_LOAD_PARAMETERS
  USE YOETHF,    ONLY : YOETHF_LOAD_PARAMETERS
  USE YOEPHLI  , ONLY : YREPHLI, YREPHLI_LOAD_PARAMETERS

  USE CLOUDSC_STATE_TYPE_MOD, ONLY: CLOUDSC_STATE_TYPE
  USE CLOUDSC_AUX_TYPE_MOD, ONLY: CLOUDSC_AUX_TYPE
  USE CLOUDSC_FLUX_TYPE_MOD, ONLY: CLOUDSC_FLUX_TYPE
  USE FILE_IO_MOD, ONLY: INPUT_INITIALIZE, INPUT_FINALIZE, LOAD_SCALAR, LOAD_ARRAY
  USE EXPAND_MOD, ONLY: EXPAND, LOAD_AND_EXPAND, LOAD_AND_EXPAND_STATE, GET_OFFSETS
  USE VALIDATE_MOD, ONLY: VALIDATE
  USE CLOUDSC_MPI_MOD, ONLY: IRANK
  USE FIELD_MODULE, ONLY: FIELD_2RB, FIELD_3RB, FIELD_4RB, FIELD_2IM, FIELD_2LM, FIELD_3RB_PTR
  USE FIELD_FACTORY_MODULE, ONLY: FIELD_NEW, FIELD_DELETE

  IMPLICIT NONE


  TYPE CLOUDSC_FIELD_STATE
    INTEGER(KIND=JPIM)                   :: NPROMA, KLEV    ! Grid points and vertical levels per block
    INTEGER(KIND=JPIM)                   :: NGPTOT, NBLOCKS ! Total number of grid points and blocks
    INTEGER(KIND=JPIM)                   :: KFLDX
    LOGICAL(KIND=JPLM)                   :: LDSLPHY
    LOGICAL(KIND=JPLM)                   :: LDMAINCALL      ! T if main call to cloudsc
    REAL(KIND=JPRB)                      :: PTSPHY          ! Physics timestep

    TYPE(CLOUDSC_STATE_TYPE) :: TENDENCY_LOC, TENDENCY_TMP
    TYPE(CLOUDSC_AUX_TYPE) :: AUX
    TYPE(CLOUDSC_FLUX_TYPE) :: FLUX
    ! Underlying data buffers for AOSOA allcoated STATE_TYPE arrays
    REAL(KIND=JPRB), ALLOCATABLE :: B_TMP(:,:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)


  CONTAINS
    PROCEDURE :: LOAD => CLOUDSC_FIELD_STATE_LOAD
    PROCEDURE :: VALIDATE => CLOUDSC_FIELD_STATE_VALIDATE
    PROCEDURE :: FINALIZE => CLOUDSC_FIELD_STATE_FINALIZE
  END TYPE CLOUDSC_FIELD_STATE

  INTERFACE FIELD_INIT
    PROCEDURE FIELD_INIT_R1, FIELD_INIT_R2, FIELD_INIT_R3, FIELD_INIT_STATE
  END INTERFACE FIELD_INIT


CONTAINS

  SUBROUTINE LOAD_AND_EXPAND_FIELD_2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2IM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    INTEGER(KIND=JPIM), ALLOCATABLE :: BUFFER(:)
    INTEGER(KIND=JPIM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_INT2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D(NAME, FIELD, NLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_2LM), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    LOGICAL(KIND=JPLM), ALLOCATABLE :: BUFFER(:)
    LOGICAL(KIND=JPLM), POINTER :: PTR(:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, 1, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_LOG2D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_3D(NAME, FIELD, NLON, NLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_3RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV, NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, 1, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_3D

  SUBROUTINE LOAD_AND_EXPAND_FIELD_4D(NAME, FIELD, NLON, NLEV, NDIM, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CHARACTER(LEN=*), INTENT(IN) :: NAME
    CLASS(FIELD_4RB), INTENT(INOUT) :: FIELD
    INTEGER(KIND=JPIM), INTENT(IN) :: NLON, NLEV,NDIM,  NPROMA, NGPTOT, NBLOCKS
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    REAL(KIND=JPRB), ALLOCATABLE :: BUFFER(:,:,:)
    REAL(KIND=JPRB), POINTER :: PTR(:,:,:,:)
    INTEGER(KIND=JPIM) :: START, END, SIZE

    CALL GET_OFFSETS(START, END, SIZE, NLON, NDIM, NLEV, NGPTOT, NGPTOTG)
    ALLOCATE(BUFFER(SIZE, NLEV, NDIM))
    CALL LOAD_ARRAY(NAME, START, END, SIZE, NLON, NLEV, NDIM, BUFFER)
    CALL FIELD%GET_HOST_DATA_RDWR(PTR)
    CALL EXPAND(BUFFER, PTR, SIZE, NPROMA, NLEV, NDIM, NGPTOT, NBLOCKS)
    DEALLOCATE(BUFFER)
  END SUBROUTINE LOAD_AND_EXPAND_FIELD_4D

  SUBROUTINE FIELD_INIT_R1(FIELD, NPROMA,NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R1

  SUBROUTINE FIELD_INIT_R2(FIELD, NPROMA, NLEV, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R2

  SUBROUTINE FIELD_INIT_R3(FIELD, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate and initialize (zero) empty output fields
    REAL(KIND=JPRB), ALLOCATABLE, INTENT(INOUT) :: FIELD(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B
    ALLOCATE(FIELD(NPROMA, NLEV, NDIM, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       FIELD(:,:,:,B) = 0.0_JPRB
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_R3

  SUBROUTINE FIELD_INIT_STATE(STATE, BUFFER, NPROMA, NLEV, NDIM, NBLOCKS)
    ! Allocate empty state struct array
    !
    ! Note, the resulting AOSOA pattern is a pain to roll by hand in Fortran
    ! and could be done either via parameterized derived types or templating.
    TYPE(CLOUDSC_STATE_TYPE), ALLOCATABLE, INTENT(INOUT) :: STATE(:)
    REAL(KIND=JPRB), ALLOCATABLE, TARGET, INTENT(INOUT) :: BUFFER(:,:,:,:)
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NLEV, NDIM, NBLOCKS
    INTEGER(KIND=JPIM) :: B, NFIELDS

    NFIELDS = 3+NDIM
    ALLOCATE(STATE(NBLOCKS))
    ALLOCATE(BUFFER(NPROMA, NLEV, NFIELDS, NBLOCKS))

!$OMP PARALLEL DO DEFAULT(SHARED), PRIVATE(B) schedule(runtime)
    DO B=1, NBLOCKS
       STATE(B)%T => BUFFER(:,:,1,B)
       STATE(B)%A => BUFFER(:,:,2,B)
       STATE(B)%Q => BUFFER(:,:,3,B)
       STATE(B)%CLD => BUFFER(:,:,4:NFIELDS,B)
    END DO
!$omp end parallel do
  END SUBROUTINE FIELD_INIT_STATE

  SUBROUTINE CLOUDSC_FIELD_STATE_LOAD(SELF, NPROMA, NGPTOT, NGPTOTG, USE_PACKED)
#ifdef HAVE_CUDA
    USE FIELD_DEFAULTS_MODULE, ONLY: INIT_MAP_DEVPTR, INIT_PINNED_VALUE
#endif
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG
    ! Use this toggle to switch between standalone fields and bulk-allocated ones.
    LOGICAL, INTENT(IN), OPTIONAL :: USE_PACKED

    INTEGER(KIND=JPIM) :: KLON, NFIELDS
    INTEGER(KIND=JPIM) :: START, END, SIZE

    LOGICAL :: LLPACKED

    ! Set this flag to disable host-mapped device pointers
#ifdef HAVE_CUDA
#ifdef HAVE_FIELD_API_MAPPED_MEMORY
    INIT_MAP_DEVPTR = .TRUE.
#else
    INIT_MAP_DEVPTR = .FALSE.
#endif
    ! Set this flag to enable pinning of fields in page-locked memory
#ifdef HAVE_FIELD_API_PINNED_MEMORY
    INIT_PINNED_VALUE = .TRUE.
#elif defined(HAVE_CUDA)
    INIT_PINNED_VALUE = .FALSE.
#endif
#endif

    LLPACKED = .FALSE.
    IF (PRESENT(USE_PACKED)) LLPACKED = USE_PACKED


    CALL INPUT_INITIALIZE(NAME='input')

    SELF%NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)

    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', SELF%KLEV)
    CALL LOAD_SCALAR('KFLDX', SELF%KFLDX)

    CALL GET_OFFSETS(START, END, SIZE, KLON, SELF%KLEV, NCLV, NGPTOT, NGPTOTG)
    
    ! Initialize and load aux types
    CALL SELF%AUX%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    ! 2D Fields  
    CALL LOAD_AND_EXPAND_FIELD_2D('PLSM', SELF%AUX%F_PLSM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_LOG2D('LDCUM', SELF%AUX%F_LDCUM, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_INT2D('KTYPE', SELF%AUX%F_KTYPE, KLON, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    ! 3D fields
    CALL LOAD_AND_EXPAND_FIELD_3D('PLCRIT_AER', SELF%AUX%F_PLCRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PICRIT_AER', SELF%AUX%F_PICRIT_AER, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PRE_ICE', SELF%AUX%F_PRE_ICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PCCN', SELF%AUX%F_PCCN, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PNICE', SELF%AUX%F_PNICE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PT', SELF%AUX%F_PT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PQ', SELF%AUX%F_PQ, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFA', SELF%AUX%F_PVFA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFL', SELF%AUX%F_PVFL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVFI', SELF%AUX%F_PVFI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNA', SELF%AUX%F_PDYNA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNL', SELF%AUX%F_PDYNL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PDYNI', SELF%AUX%F_PDYNI, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRSW', SELF%AUX%F_PHRSW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PHRLW', SELF%AUX%F_PHRLW, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PVERVEL', SELF%AUX%F_PVERVEL, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAP', SELF%AUX%F_PAP, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PAPH', SELF%AUX%F_PAPH, KLON, SELF%KLEV+1, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLU', SELF%AUX%F_PLU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PLUDE', SELF%AUX%F_PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSNDE', SELF%AUX%F_PSNDE, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFU', SELF%AUX%F_PMFU, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PMFD', SELF%AUX%F_PMFD, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PA', SELF%AUX%F_PA, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('PSUPSAT', SELF%AUX%F_PSUPSAT, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    ! 4D fields
    CALL LOAD_AND_EXPAND_FIELD_4D('PCLV', SELF%AUX%F_PCLV, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! Initialize and load fluxes
    CALL SELF%FLUX%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    
    ! Initialize and load tendencies
    CALL SELF%TENDENCY_LOC%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    CALL SELF%TENDENCY_TMP%INIT(NPROMA, NGPTOT, KLON, SELF%KLEV, SELF%KFLDX, SELF%NBLOCKS, NGPTOTG, USE_PACKED)
    ! LOAD TENDENCIES (we don't need to load TENDENCY_LOC)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_T', SELF%TENDENCY_TMP%F_T, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_A', SELF%TENDENCY_TMP%F_A, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_3D('TENDENCY_TMP_Q', SELF%TENDENCY_TMP%F_Q, KLON, SELF%KLEV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_FIELD_4D('TENDENCY_TMP_CLD', SELF%TENDENCY_TMP%F_CLD, KLON, SELF%KLEV, NCLV, NPROMA, NGPTOT, SELF%NBLOCKS, NGPTOTG)

    ! Initialize global parameters from the input file
    CALL LOAD_SCALAR('PTSPHY', SELF%PTSPHY)
    CALL LOAD_SCALAR('LDSLPHY', SELF%LDSLPHY)
    CALL LOAD_SCALAR('LDMAINCALL', SELF%LDMAINCALL)
    CALL YOMCST_LOAD_PARAMETERS()
    CALL YOETHF_LOAD_PARAMETERS()
    CALL YRECLDP_LOAD_PARAMETERS()
    CALL YREPHLI_LOAD_PARAMETERS()

    CALL INPUT_FINALIZE()

  END SUBROUTINE CLOUDSC_FIELD_STATE_LOAD

  SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE(SELF, NPROMA, NGPTOT, NGPTOTG)
    ! Validate the correctness of output against reference data
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    INTEGER(KIND=JPIM), INTENT(IN) :: NPROMA, NGPTOT
    INTEGER(KIND=JPIM), INTENT(IN), OPTIONAL :: NGPTOTG

    REAL(KIND=JPRB), ALLOCATABLE :: PLUDE(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PCOVPTOT(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PRAINFRAC_TOPRFZ(:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQIF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQLNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQNNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQRF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQSF(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQRNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFCQSNG(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQLTUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFSQITUR(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFPLSN(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSL(:,:,:)
    REAL(KIND=JPRB), ALLOCATABLE :: PFHPSN(:,:,:)
    TYPE(STATE_TYPE), ALLOCATABLE :: TENDENCY_LOC(:)
    REAL(KIND=JPRB), ALLOCATABLE :: B_LOC(:,:,:,:)

    INTEGER(KIND=JPIM) :: NBLOCKS, KLON, KLEV, KFLDX

    CALL INPUT_INITIALIZE(NAME='reference')

    NBLOCKS = (NGPTOT / NPROMA) + MIN(MOD(NGPTOT,NPROMA), 1)
    CALL LOAD_SCALAR('KLON', KLON)
    CALL LOAD_SCALAR('KLEV', KLEV)
    CALL LOAD_SCALAR('KFLDX', KFLDX)

    ! Write variable validation header
    IF (IRANK == 0) THEN
      print '(1X,A20,1X,A3,5(1X,A20))', &
           & 'Variable','Dim', 'MinValue','MaxValue','AbsMaxErr','AvgAbsErr/GP','MaxRelErr-%'
    END IF

    ! Load reference data and expand to our block layout
    CALL LOAD_AND_EXPAND('PLUDE', PLUDE, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PCOVPTOT', PCOVPTOT, KLON, SELF%KLEV, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, KLON, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLF', PFSQLF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQIF', PFSQIF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQLNG', PFCQLNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQNNG', PFCQNNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQRF', PFSQRF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQSF', PFSQSF, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQRNG', PFCQRNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFCQSNG', PFCQSNG, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQLTUR', PFSQLTUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFSQITUR', PFSQITUR, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSL', PFPLSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFPLSN', PFPLSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSL', PFHPSL, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND('PFHPSN', PFHPSN, KLON, SELF%KLEV+1, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL LOAD_AND_EXPAND_STATE('TENDENCY_LOC', TENDENCY_LOC, B_LOC, KLON, SELF%KLEV, NCLV, &
         & NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL INPUT_FINALIZE()

    ! Actual variable validation
    CALL VALIDATE('PLUDE', PLUDE, SELF%AUX%F_PLUDE%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PCOVPTOT', PCOVPTOT, SELF%AUX%F_PCOVPTOT%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PRAINFRAC_TOPRFZ', PRAINFRAC_TOPRFZ, SELF%AUX%F_PRAINFRAC_TOPRFZ%PTR, NPROMA, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLF', PFSQLF, SELF%FLUX%F_PFSQLF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQIF', PFSQIF, SELF%FLUX%F_PFSQIF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQLNG', PFCQLNG, SELF%FLUX%F_PFCQLNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQNNG', PFCQNNG, SELF%FLUX%F_PFCQNNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQRF', PFSQRF, SELF%FLUX%F_PFSQRF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQSF', PFSQSF, SELF%FLUX%F_PFSQSF%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQRNG', PFCQRNG, SELF%FLUX%F_PFCQRNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFCQSNG', PFCQSNG, SELF%FLUX%F_PFCQSNG%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQLTUR', PFSQLTUR, SELF%FLUX%F_PFSQLTUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFSQITUR', PFSQITUR, SELF%FLUX%F_PFSQITUR%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSL', PFPLSL, SELF%FLUX%F_PFPLSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFPLSN', PFPLSN, SELF%FLUX%F_PFPLSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSL', PFHPSL, SELF%FLUX%F_PFHPSL%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('PFHPSN', PFHPSN, SELF%FLUX%F_PFHPSN%PTR, NPROMA, SELF%KLEV+1, NGPTOT, NBLOCKS, NGPTOTG)

    CALL VALIDATE('TENDENCY_LOC%A', B_LOC(:,:,2,:), SELF%TENDENCY_LOC%F_A%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%Q', B_LOC(:,:,3,:), SELF%TENDENCY_LOC%F_Q%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%T', B_LOC(:,:,1,:), SELF%TENDENCY_LOC%F_T%PTR, NPROMA, SELF%KLEV, NGPTOT, NBLOCKS, NGPTOTG)
    CALL VALIDATE('TENDENCY_LOC%CLD', B_LOC(:,:,4:,:), SELF%TENDENCY_LOC%F_CLD%PTR, NPROMA, SELF%KLEV, NCLV, NGPTOT, NBLOCKS, NGPTOTG)

  END SUBROUTINE CLOUDSC_FIELD_STATE_VALIDATE

  
  SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE(SELF)
    CLASS(CLOUDSC_FIELD_STATE) :: SELF
    CALL SELF%AUX%FINAL()
    CALL SELF%FLUX%FINAL()
    CALL SELF%TENDENCY_LOC%FINAL()
    CALL SELF%TENDENCY_TMP%FINAL()
  END SUBROUTINE CLOUDSC_FIELD_STATE_FINALIZE


END MODULE CLOUDSC_FIELD_STATE_MOD
